
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Queries · DataAxesFormats.jl v0.1.2
</title>
<meta name="title" content="Queries · DataAxesFormats.jl v0.1.2"/>
<meta property="og:title" content="Queries · DataAxesFormats.jl v0.1.2"/>
<meta property="twitter:title" content="Queries · DataAxesFormats.jl v0.1.2"/>
<meta name="description" content="Documentation for DataAxesFormats.jl v0.1.2."/>
<meta property="og:description" content="Documentation for DataAxesFormats.jl v0.1.2."/>
<meta property="twitter:description" content="Documentation for DataAxesFormats.jl v0.1.2."/>
<script data-outdated-warner src="assets/warner.js">
</script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/>
<script>documenterBaseURL="."
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js">
</script>
<script src="search_index.js">
</script>
<script src="siteinfo.js">
</script>
<script src="../versions.js">
</script>
<link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/>
<link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/>
<link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/>
<link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/>
<link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/>
<link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/>
<script src="assets/themeswap.js">
</script>
</head>
<body>
<div id="documenter">
<nav class="docs-sidebar">
<a class="docs-logo" href="index.html">
<img src="assets/logo.svg" alt="DataAxesFormats.jl v0.1.2 logo"/>
</a>
<div class="docs-package-name">
<span class="docs-autofit">
<a href="index.html">DataAxesFormats.jl v0.1.2
</a>
</span>
</div>
<button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)
</button>
<ul class="docs-menu">
<li>
<a class="tocitem" href="index.html">Daf
</a>
</li>
<li>
<a class="tocitem" href="readers.html">Readers
</a>
</li>
<li>
<a class="tocitem" href="writers.html">Writers
</a>
</li>
<li>
<a class="tocitem" href="read_only.html">Read-only
</a>
</li>
<li class="is-active">
<a class="tocitem" href="queries.html">Queries
</a>
<ul class="internal">
<li>
<a class="tocitem" href="#Construction">
<span>Construction
</span>
</a>
</li>
<li>
<a class="tocitem" href="#Functions">
<span>Functions
</span>
</a>
</li>
<li>
<a class="tocitem" href="#Syntax">
<span>Syntax
</span>
</a>
</li>
<li>
<a class="tocitem" href="#Query-Operators">
<span>Query Operators
</span>
</a>
</li>
<li>
<a class="tocitem" href="#Index">
<span>Index
</span>
</a>
</li>
</ul>
</li>
<li>
<a class="tocitem" href="tokens.html">Tokens
</a>
</li>
<li>
<a class="tocitem" href="views.html">Views
</a>
</li>
<li>
<a class="tocitem" href="chains.html">Chains
</a>
</li>
<li>
<a class="tocitem" href="computations.html">Computations
</a>
</li>
<li>
<a class="tocitem" href="copies.html">Copies
</a>
</li>
<li>
<a class="tocitem" href="concat.html">Concat
</a>
</li>
<li>
<a class="tocitem" href="adapters.html">Adapters
</a>
</li>
<li>
<a class="tocitem" href="contracts.html">Contracts
</a>
</li>
<li>
<a class="tocitem" href="formats.html">Formats
</a>
</li>
<li>
<a class="tocitem" href="keys.html">Keys
</a>
</li>
<li>
<a class="tocitem" href="memory_format.html">Memory Format
</a>
</li>
<li>
<a class="tocitem" href="h5df_format.html">H5DF Format
</a>
</li>
<li>
<a class="tocitem" href="files_format.html">Files Format
</a>
</li>
<li>
<a class="tocitem" href="complete.html">Complete Repositories
</a>
</li>
<li>
<a class="tocitem" href="anndata_format.html">AnnData Format
</a>
</li>
<li>
<a class="tocitem" href="reconstruction.html">Reconstruction
</a>
</li>
<li>
<a class="tocitem" href="registry.html">Operations registry
</a>
</li>
<li>
<a class="tocitem" href="operations.html">Query operations
</a>
</li>
<li>
<a class="tocitem" href="storage_types.html">Storage types
</a>
</li>
<li>
<a class="tocitem" href="groups.html">Groups
</a>
</li>
<li>
<a class="tocitem" href="example_data.html">Example data
</a>
</li>
</ul>
<div class="docs-version-selector field has-addons">
<div class="control">
<span class="docs-label button is-static is-size-7">Version
</span>
</div>
<div class="docs-selector control is-expanded">
<div class="select is-fullwidth is-size-7">
<select id="documenter-version-selector">
</select>
</div>
</div>
</div>
</nav>
<div class="docs-main">
<header class="docs-navbar">
<a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#">
</a>
<nav class="breadcrumb">
<ul class="is-hidden-mobile">
<li class="is-active">
<a href="queries.html">Queries
</a>
</li>
</ul>
<ul class="is-hidden-tablet">
<li class="is-active">
<a href="queries.html">Queries
</a>
</li>
</ul>
</nav>
<div class="docs-right">
<a class="docs-navbar-link" href="https://github.com/tanaylab/DataAxesFormats.jl/blob/main{path}?plain=1#L{line}" title="View the repository on GitHub">
<span class="docs-icon fa-brands">
</span>
<span class="docs-label is-hidden-touch">GitHub
</span>
</a>
<a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings">
</a>
<a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings">
</a>
</div>
</header>
<article class="content" id="documenter-page">
<h1 id="Queries">
<a class="docs-heading-anchor" href="#Queries">Queries
</a>
<a id="Queries-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Queries" title="Permalink">
</a>
</h1>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries">
<a class="docstring-binding" href="#DataAxesFormats.Queries">
<code>DataAxesFormats.Queries
</code>
</a> — 
<span class="docstring-category">Module
</span>
</summary>
<section>
<div>
<p>Extract data from a 
<a href="formats.html#DataAxesFormats.Formats.DafReader">
<code>DafReader
</code>
</a>.
</p>
</div>
</section>
</details>
</article>
<h2 id="Construction">
<a class="docs-heading-anchor" href="#Construction">Construction
</a>
<a id="Construction-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Construction" title="Permalink">
</a>
</h2>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.Query">
<a class="docstring-binding" href="#DataAxesFormats.Queries.Query">
<code>DataAxesFormats.Queries.Query
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">Query(
    query::QueryString,
    operand_only::Maybe{Type{QueryOperation}} = nothing,
) &lt;: QueryOperation
</code>
</pre>
<p>A query is a description of a (sub-)process for extracting some data from a 
<a href="formats.html#DataAxesFormats.Formats.DafReader">
<code>DafReader
</code>
</a>. A full query is a sequence of 
<a href="registry.html#DataAxesFormats.Registry.QueryOperation">
<code>QueryOperation
</code>
</a>, that when applied one at a time on some 
<a href="formats.html#DataAxesFormats.Formats.DafReader">
<code>DafReader
</code>
</a>, result in a scalar, vector or matrix result.
</p>
<p>To apply a query, invoke 
<a href="queries.html#DataAxesFormats.Queries.get_query">
<code>get_query
</code>
</a> to apply a query to some 
<a href="formats.html#DataAxesFormats.Formats.DafReader">
<code>DafReader
</code>
</a> data (you can also use the shorthand 
<code>daf[query]
</code> instead of 
<code>get_query(daf, query)
</code> and also write 
<code>query |&gt; get_query(daf)
</code> which is useful when constructing a query from parts using 
<code>|&gt;
</code>). By default, 
<a href="queries.html#DataAxesFormats.Queries.get_query">
<code>get_query
</code>
</a> will cache their results in memory as 
<a href="formats.html#DataAxesFormats.Formats.CacheGroup">
<code>QueryData
</code>
</a>, to speed up repeated queries. This may lock up large amounts of memory. Using 
<code>daf[query]
</code> does not cache the results; you can also use 
<a href="formats.html#DataAxesFormats.Formats.empty_cache!">
<code>empty_cache!
</code>
</a> to release the memory.
</p>
<p>Queries can be constructed in two ways. In code, a query can be built by chaining query operations (e.g., the expression 
<code>Axis(&quot;gene&quot;) |&gt; Lookup(&quot;is_marker&quot;) |&gt; get_query(daf)
</code> looks up the 
<code>is_marker
</code> vector property of the 
<code>gene
</code> axis).
</p>
<p>Alternatively, a query can be parsed from a string, which needs to be parsed into a 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a> object (e.g., the above can be written as 
<code>daf[&quot;/gene:is_marker&quot;]
</code>). See the 
<a href="queries.html#DataAxesFormats.Queries.QUERY_OPERATORS">
<code>QUERY_OPERATORS
</code>
</a> for a table of supported operators. Spaces (and comments) around the operators are optional; see 
<a href="tokens.html#DataAxesFormats.Tokens.tokenize">
<code>tokenize
</code>
</a> for details. You can also convert a 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a> to a 
<code>string
</code> (or 
<code>print
</code> it, etc.) to see its representation. This is used for 
<code>error
</code> messages and as a key when caching query results.
</p>
<p>Since query strings use 
<code>\
</code> as an escape character, it is easier to use 
<code>raw
</code> string literals for queries (e.g., 
<code>Query(raw&quot;cell = ATCG\:B1 : age&quot;)
</code> vs. 
<code>Query(&quot;cell = ATCG\\:B1 : age&quot;)
</code>). To make this even easier we provide the 
<a href="queries.html#DataAxesFormats.Queries.@q_str">
<code>q
</code>
</a> macro (e.g., 
<code>q&quot;cell = ATCG\:B1 : batch&quot;
</code>) which works similarly to Julia&#39;s standard 
<code>r
</code> macro for literal 
<code>Regex
</code> strings.
</p>
<p>If the provided query string contains only an operand, and 
<code>operand_only
</code> is specified, it is used as the operator (i.e., 
<code>Query(&quot;metacell&quot;)
</code> is an error, but 
<code>Query(&quot;metacell&quot;, Axis)
</code> is the same as 
<code>Axis(&quot;metacell&quot;)
</code>). This is useful when providing suffix queries (e.g., for 
<a href="queries.html#DataAxesFormats.Queries.get_frame">
<code>get_frame
</code>
</a>).
</p>
<p>Being able to represent queries as strings allows for reading them from configuration files and letting the user input them in an application UI (e.g., allowing the user to specify the X, Y and/or colors of a scatter plot using queries). At the same time, being able to incrementally build queries using code allows for convenient reuse (e.g., reusing axis sub-queries in 
<code>Daf
</code> views), without having to go through the string representation.
</p>
<p>
<code>Daf
</code> provides a comprehensive set of 
<a href="registry.html#DataAxesFormats.Registry.QueryOperation">
<code>QueryOperation
</code>
</a>s that can be used to construct queries. The 
<a href="queries.html#DataAxesFormats.Queries.QUERY_OPERATORS">
<code>QUERY_OPERATORS
</code>
</a> listed below provide the basic functionality (e.g., specifying an 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a> or a property 
<a href="queries.html#DataAxesFormats.Queries.Lookup">
<code>Lookup
</code>
</a>). In addition, 
<code>Daf
</code> provides computation operations (
<a href="registry.html#DataAxesFormats.Registry.EltwiseOperation">
<code>EltwiseOperation
</code>
</a> and 
<a href="registry.html#DataAxesFormats.Registry.ReductionOperation">
<code>ReductionOperation
</code>
</a>), allowing for additional operations to be provided by external packages.
</p>
<p>Obviously not all possible combinations of operations make sense (e.g., 
<code>Lookup(&quot;is_marker&quot;) |&gt; Axis(&quot;cell&quot;)
</code> will not work). For the full list of valid combinations, see 
<a href="queries.html#DataAxesFormats.Queries.NAMES_QUERY">
<code>NAMES_QUERY
</code>
</a>, 
<a href="queries.html#DataAxesFormats.Queries.SCALAR_QUERY">
<code>SCALAR_QUERY
</code>
</a>, 
<a href="queries.html#DataAxesFormats.Queries.VECTOR_QUERY">
<code>VECTOR_QUERY
</code>
</a> and 
<a href="queries.html#DataAxesFormats.Queries.MATRIX_QUERY">
<code>MATRIX_QUERY
</code>
</a> below.
</p>
<div class="admonition is-info" id="Note-c9e6def924b5c91c">
<header class="admonition-header">Note
<a class="admonition-anchor" href="#Note-c9e6def924b5c91c" title="Permalink">
</a>
</header>
<div class="admonition-body">
<p>This has started as a very simple query language (which it still is, for the simple cases) but became complex to allow for useful but complex scenarios. In particular, the approach here of using a concatenative language (similar to 
<code>ggplot
</code>) makes simple things simpler, but became less unnatural for some of the more advanced operations. However, using an RPN or a LISP notation to better support such cases would have ended up with a much less nice syntax for the simple cases.
</p>
<p>Hopefully we have covered sufficient ground so that we won&#39;t need to add further operations (except for more element-wise and reduction operations). In most cases, you can write code that accesses the vectors/matrix data and performs whatever computation you want instead of writing a complex query; however, this isn&#39;t an option when defining views or adapters, which rely on the query mechanism for specifying the data.
</p>
</div>
</div>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.@q_str">
<a class="docstring-binding" href="#DataAxesFormats.Queries.@q_str">
<code>DataAxesFormats.Queries.@q_str
</code>
</a> — 
<span class="docstring-category">Macro
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">q&quot;...&quot;
</code>
</pre>
<p>Shorthand for parsing a literal string as a 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>. This is equivalent to 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>
<code>(raw&quot;...&quot;)
</code>, that is, a 
<code>\
</code> can be placed in the string without escaping it (except for before a 
<code>&quot;
</code>). This is very convenient for literal queries (e.g., 
<code>q&quot;/ cell = ATCG\:B1 : batch&quot;
</code> == 
<code>Query(raw&quot;/ cell = ATCG\:B1 : batch&quot;)
</code> == 
<code>Query(&quot;/ cell = ATCG\\:B1 : batch&quot;)
</code> == 
<code>Axis(&quot;cell&quot;) |&gt; IsEqual(&quot;ATCG:B1&quot;) |&gt; Lookup(&quot;batch&quot;))
</code>.
</p>
<pre>
<code class="language-julia hljs">println(&quot;/ cell = ATCG\\:B1 : batch&quot;)
println(q&quot;/ cell = ATCG\:B1 : batch&quot;)

# output

/ cell = ATCG\:B1 : batch
/ cell = ATCG\:B1 : batch
</code>
</pre>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.QueryString">
<a class="docstring-binding" href="#DataAxesFormats.Queries.QueryString">
<code>DataAxesFormats.Queries.QueryString
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<p>Most operations that take a query allow passing a string to be parsed into a query, or an actual 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a> object. This type is used as a convenient notation for such query parameters.
</p>
</div>
</section>
</details>
</article>
<h2 id="Functions">
<a class="docs-heading-anchor" href="#Functions">Functions
</a>
<a id="Functions-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink">
</a>
</h2>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.get_query">
<a class="docstring-binding" href="#DataAxesFormats.Queries.get_query">
<code>DataAxesFormats.Queries.get_query
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">get_query(
    daf::DafReader,
    query::QueryString;
    [cache::Bool = true]
)::Union{StorageScalar, NamedVector, NamedMatrix}

get_query(
    daf::DafReader;
    cache::Bool = true,
)
</code>
</pre>
<p>Apply the full 
<code>query
</code> to the 
<code>Daf
</code> data and return the result. By default, this will cache results, so repeated queries will be accelerated. This may consume a large amount of memory. You can disable it by specifying 
<code>cache = false
</code>, or release the cached data using 
<a href="formats.html#DataAxesFormats.Formats.empty_cache!">
<code>empty_cache!
</code>
</a>.
</p>
<p>As a shorthand syntax you can also invoke this using 
<code>getindex
</code>, that is, using the 
<code>[]
</code> operator (e.g., 
<code>daf[q&quot;/ cell&quot;]
</code> is equivalent to 
<code>get_query(daf, q&quot;/ cell&quot;; cache = false)
</code>). Finally, you can use 
<code>|&gt;
</code> to invoke the query, which is especially useful when constructing it from the operations 
<code>Axis(&quot;cell&quot;) |&gt; get_query(daf)
</code> or even 
<code>&quot;/ cell&quot; |&gt; get_query(daf)
</code>.
</p>
<div class="admonition is-info" id="Note-bf21f037f8a82ae1">
<header class="admonition-header">Note
<a class="admonition-anchor" href="#Note-bf21f037f8a82ae1" title="Permalink">
</a>
</header>
<div class="admonition-body">
<p>Using 
<code>get_query
</code>, the query 
<em>is
</em> cached (by default). Using 
<code>[...]
</code>, the query is 
<em>not
</em> cached. That is, 
<code>[...]
</code> is mostly used for one-off queries (and in interactive sessions, etc.) while 
<code>get_query
</code> is used for more &quot;fundamental&quot; queries that are expected to be re-used.
</p>
</div>
</div>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.has_query">
<a class="docstring-binding" href="#DataAxesFormats.Queries.has_query">
<code>DataAxesFormats.Queries.has_query
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">has_query(daf::DafReader, query::QueryString)::Bool
</code>
</pre>
<p>Return whether the 
<code>query
</code> can be applied to the 
<code>Daf
</code> data.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.get_frame">
<a class="docstring-binding" href="#DataAxesFormats.Queries.get_frame">
<code>DataAxesFormats.Queries.get_frame
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">get_frame(
    daf::DafReader,
    axis::QueryString,
    [columns::Maybe{FrameColumns} = nothing;
    cache::Bool = true]
)::DataFrame end
</code>
</pre>
<p>Return a 
<code>DataFrame
</code> containing multiple vectors of the same 
<code>axis
</code>.
</p>
<p>The 
<code>axis
</code> can be either just the name of an axis (e.g., 
<code>&quot;cell&quot;
</code>), or a query for the axis (e.g., 
<code>q&quot;/ cell&quot;
</code>), possibly using a mask (e.g., 
<code>q&quot;/ cell &amp; age &gt; 1&quot;
</code>). The result of the query must be a vector of unique axis entry names.
</p>
<p>If 
<code>columns
</code> is not specified, the data frame will contain all the vector properties of the axis, in alphabetical order (since 
<code>DataFrame
</code> has no concept of named rows, the 1st column will contain the name of the axis entry).
</p>
<p>By default, this will cache results of all queries. This may consume a large amount of memory. You can disable it by specifying 
<code>cache = false
</code>, or release the cached data using 
<a href="formats.html#DataAxesFormats.Formats.empty_cache!">
<code>empty_cache!
</code>
</a>.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.FrameColumn">
<a class="docstring-binding" href="#DataAxesFormats.Queries.FrameColumn">
<code>DataAxesFormats.Queries.FrameColumn
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<p>Specify a column for 
<a href="queries.html#DataAxesFormats.Queries.get_frame">
<code>get_frame
</code>
</a> for some axis. The most generic form is a pair 
<code>&quot;column_name&quot; =&gt; query
</code>. Two shorthands apply: the pair 
<code>&quot;column_name&quot; =&gt; &quot;=&quot;
</code> is a shorthand for the pair 
<code>&quot;column_name&quot; =&gt; &quot;: column_name&quot;
</code>, and so is the shorthand 
<code>&quot;column_name&quot;
</code> (simple string).
</p>
<p>We also allow specifying tuples instead of pairs to make it easy to invoke the API from other languages such as Python which do not have the concept of a 
<code>Pair
</code>.
</p>
<p>The query is combined with the axis query as follows (using 
<a href="queries.html#DataAxesFormats.Queries.full_vector_query">
<code>full_vector_query
</code>
</a>:
</p>
<ul>
<li>If the query contains 
<a href="queries.html#DataAxesFormats.Queries.GroupBy">
<code>GroupBy
</code>
</a>, then the query must repeat any mask specified for the axis query. That is, if the axis query is 
<code>metacell &amp; type = B
</code>, then the column query must be 
<code>/ cell &amp; metacell =&gt; type = B @ metacell : age %&gt; Mean
</code>. Sorry for the inconvenience. TODO: Automatically inject the mask into 
<a href="queries.html#DataAxesFormats.Queries.GroupBy">
<code>GroupBy
</code>
</a> column queries.
</li>
<li>Otherwise, if the query starts with a (single) axis, then it should only contain a reduction; the axis query is automatically injected following it. That is, if the axis query is 
<code>gene &amp; is_marker
</code>, then the full query for the column query 
<code>/ metacell : fraction %&gt; Mean
</code> will be 
<code>/ metacell / gene : fraction %&gt; Mean
</code> (the mean gene expression in all metacells). We can&#39;t just concatenate the axis query and the columns query here, is because Julia, in its infinite wisdom, uses column-major matrices, like R and matlab; so reduction eliminates the rows instead of the columns of the matrix.
</li>
<li>Otherwise (the typical case), we simply concatenate the axis query and the column query. That is, of the axis query is 
<code>cell &amp; batch = B1
</code> and the column query is 
<code>: age
</code>, then the full query will be 
<code>cell &amp; batch = B1 : age
</code>. This is the simplest and most common case.
</li>
</ul>
<p>In all cases the (full) query must return a value for each entry of the axis.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.FrameColumns">
<a class="docstring-binding" href="#DataAxesFormats.Queries.FrameColumns">
<code>DataAxesFormats.Queries.FrameColumns
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<p>Specify all the columns to collect for a frame. We would have liked to specify this as 
<code>AbstractVector{&lt;:FrameColumn}
</code> but Julia in its infinite wisdom considers 
<code>[&quot;a&quot;, &quot;b&quot; =&gt; &quot;c&quot;]
</code> to be a 
<code>Vector{Any}
</code>, which would require literals to be annotated with the type.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.full_vector_query">
<a class="docstring-binding" href="#DataAxesFormats.Queries.full_vector_query">
<code>DataAxesFormats.Queries.full_vector_query
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">full_vector_query(
    axis_query::Query,
    vector_query::QueryString,
    vector_name::Maybe{AbstractString} = nothing,
)::Query
</code>
</pre>
<p>Given a query for an axis, and some suffix query for a vector property, combine them into a full query for the vector values for the axis. This is used by 
<a href="queries.html#DataAxesFormats.Queries.FrameColumn">
<code>FrameColumn
</code>
</a> for 
<a href="queries.html#DataAxesFormats.Queries.get_frame">
<code>get_frame
</code>
</a> and also for queries of vector data in views.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.query_result_dimensions">
<a class="docstring-binding" href="#DataAxesFormats.Queries.query_result_dimensions">
<code>DataAxesFormats.Queries.query_result_dimensions
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">query_result_dimensions(query::QueryString)::Int
</code>
</pre>
<p>Return the number of dimensions (-1 - names, 0 - scalar, 1 - vector, 2 - matrix) of the results of a 
<code>query
</code>. This also verifies the query is syntactically valid, though it may still fail if applied to specific data due to invalid data values or types.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.query_requires_relayout">
<a class="docstring-binding" href="#DataAxesFormats.Queries.query_requires_relayout">
<code>DataAxesFormats.Queries.query_requires_relayout
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">query_requires_relayout(daf::DafReader, query::QueryString)::Bool
</code>
</pre>
<p>Whether computing the 
<code>query
</code> for the 
<code>daf
</code> data requires 
<code>relayout!
</code> of some matrix. This also verifies the query is syntactically valid and that the query can be computed, though it may still fail if applied to specific data due to invalid values or types.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.is_axis_query">
<a class="docstring-binding" href="#DataAxesFormats.Queries.is_axis_query">
<code>DataAxesFormats.Queries.is_axis_query
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">is_axis_query(query::QueryString)::Bool
</code>
</pre>
<p>Returns whether the 
<code>query
</code> specifies a (possibly masked) axis. This also verifies the query is syntactically valid, though it may still fail if applied to specific data due to invalid data values or types.
</p>
</div>
</section>
</details>
</article>
<h2 id="Syntax">
<a class="docs-heading-anchor" href="#Syntax">Syntax
</a>
<a id="Syntax-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Syntax" title="Permalink">
</a>
</h2>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.QUERY_OPERATORS">
<a class="docstring-binding" href="#DataAxesFormats.Queries.QUERY_OPERATORS">
<code>DataAxesFormats.Queries.QUERY_OPERATORS
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>Operators used to represent a 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a> as a string.
</p>
<table>
<tr>
<th style="text-align: left">Operator
</th>
<th style="text-align: center">Implementation
</th>
<th style="text-align: left">Description
</th>
</tr>
<tr>
<td style="text-align: left">
<code>/
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a>
</td>
<td style="text-align: left">Specify a vector or matrix axis (e.g., 
<code>/ cell : batch
</code> or 
<code>/ cell / gene : UMIs
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>?
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.Names">
<code>Names
</code>
</a>
</td>
<td style="text-align: left">1. Names of scalars or axes (
<code>? axes
</code>, 
<code>? scalars
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
</td>
<td style="text-align: center">
</td>
<td style="text-align: left">2. Names of vectors of axis (e.g., 
<code>/ cell ?
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
</td>
<td style="text-align: center">
</td>
<td style="text-align: left">3. Names of matrices of axes (e.g., 
<code>/ cell / gene ?
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>:
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.Lookup">
<code>Lookup
</code>
</a>
</td>
<td style="text-align: left">Lookup a property (e.g., 
<code>: version
</code>, 
<code>/ cell : batch
</code> or 
<code>/ cell / gene : UMIs
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>=&gt;
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.Fetch">
<code>Fetch
</code>
</a>
</td>
<td style="text-align: left">Fetch a property from another axis (e.g., 
<code>/ cell : batch =&gt; age
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>;
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.MaskSlice">
<code>MaskSlice
</code>
</a>
</td>
<td style="text-align: left">Slice a matrix mask (e.g. 
<code>/ cell &amp; UMIs ; gene = FOXP1 &gt; 0
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>;=
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.SquareMaskColumn">
<code>SquareMaskColumn
</code>
</a>
</td>
<td style="text-align: left">Slice a square matrix mask column (e.g. 
<code>/ cell &amp; outgoing ;= ATCG &gt; 0
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>,=
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.SquareMaskRow">
<code>SquareMaskRow
</code>
</a>
</td>
<td style="text-align: left">Slice a square matrix mask row (e.g. 
<code>/ cell &amp; outgoing ,= ATCG &gt; 0
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>!
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.AsAxis">
<code>AsAxis
</code>
</a>
</td>
<td style="text-align: left">1. Specify axis name when fetching a property (e.g., 
<code>/ cell : manual ! type =&gt; color
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
</td>
<td style="text-align: center">
</td>
<td style="text-align: left">2. Force all axis values when counting (e.g., 
<code>/ cell : batch ! * manual ! type
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
</td>
<td style="text-align: center">
</td>
<td style="text-align: left">3. Force all axis values when grouping (e.g., 
<code>/ cell : age @ batch ! %&gt; Mean
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>??
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.IfNot">
<code>IfNot
</code>
</a>
</td>
<td style="text-align: left">1. Mask excluding false-ish values (e.g., 
<code>/ cell : batch ?? =&gt; age
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
</td>
<td style="text-align: center">
</td>
<td style="text-align: left">2. Default for false-ish lookup values (e.g., 
<code>/ cell : type ?? Outlier
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
</td>
<td style="text-align: center">
</td>
<td style="text-align: left">3. Default for false-ish fetched values (e.g., 
<code>/ cell : batch ?? 1 =&gt; age
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>││
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>IfMissing
</code>
</a>
</td>
<td style="text-align: left">1. Value for missing lookup properties (e.g., 
<code>/ gene : is_marker ││ false
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
</td>
<td style="text-align: center">
</td>
<td style="text-align: left">2. Value for missing fetched properties (e.g., `/ cell : type
</td>
</tr>
<tr>
<td style="text-align: left">
</td>
<td style="text-align: center">
</td>
<td style="text-align: left">3. Value for empty reduced vectors (e.g., `/ cell : type = LMPP =&gt; age %&gt; Max
</td>
</tr>
<tr>
<td style="text-align: left">
<code>%
</code>
</td>
<td style="text-align: center">
<a href="registry.html#DataAxesFormats.Registry.EltwiseOperation">
<code>EltwiseOperation
</code>
</a>
</td>
<td style="text-align: left">Apply an element-wise operation (e.g., 
<code>/ cell / gene : UMIs % Log base 2 eps 1
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>%&gt;
</code>
</td>
<td style="text-align: center">
<a href="registry.html#DataAxesFormats.Registry.ReductionOperation">
<code>ReductionOperation
</code>
</a>
</td>
<td style="text-align: left">Apply a reduction operation (e.g., 
<code>/ cell / gene : UMIs %&gt; Sum
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>*
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.CountBy">
<code>CountBy
</code>
</a>
</td>
<td style="text-align: left">Compute counts matrix (e.g., 
<code>/ cell : age * type
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>@
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.GroupBy">
<code>GroupBy
</code>
</a>
</td>
<td style="text-align: left">1. Aggregate vector entries by a group (e.g., 
<code>/ cell : age @ type %&gt; Mean
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
</td>
<td style="text-align: center">
</td>
<td style="text-align: left">2. Aggregate matrix row entries by a group (e.g.,
<code>/ cell / gene : UMIs @ type %&gt; Max
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>&amp;
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.And">
<code>And
</code>
</a>
</td>
<td style="text-align: left">Restrict axis entries (e.g., 
<code>/ gene &amp; is_marker
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>&amp;!
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.AndNot">
<code>AndNot
</code>
</a>
</td>
<td style="text-align: left">Restrict axis entries (e.g., 
<code>/ gene &amp;! is_marker
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>│
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.Or">
<code>Or
</code>
</a>
</td>
<td style="text-align: left">Expand axis entries (e.g., 
<code>/ gene &amp; is_marker │ is_noisy
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>│!
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.OrNot">
<code>OrNot
</code>
</a>
</td>
<td style="text-align: left">Expand axis entries (e.g., 
<code>/ gene &amp; is_marker │! is_noisy
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>^
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.Xor">
<code>Xor
</code>
</a>
</td>
<td style="text-align: left">Flip axis entries (e.g., 
<code>/ gene &amp; is_marker ^ is_noisy
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>^!
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.XorNot">
<code>XorNot
</code>
</a>
</td>
<td style="text-align: left">Flip axis entries (e.g., 
<code>/ gene &amp; is_marker ^! is_noisy
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>=
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.IsEqual">
<code>IsEqual
</code>
</a>
</td>
<td style="text-align: left">1. Select an entry from an axis (e.g., 
<code>/ cell / gene = FOXP1 : UMIs
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
</td>
<td style="text-align: center">
</td>
<td style="text-align: left">2. Compare equal (e.g., 
<code>/ cell &amp; age = 1
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>!=
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.IsNotEqual">
<code>IsNotEqual
</code>
</a>
</td>
<td style="text-align: left">Compare not equal (e.g., 
<code>/ cell &amp; age != 1
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>&lt;
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.IsLess">
<code>IsLess
</code>
</a>
</td>
<td style="text-align: left">Compare less than (e.g., 
<code>/ cell &amp; age &lt; 1
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>&lt;=
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.IsLessEqual">
<code>IsLessEqual
</code>
</a>
</td>
<td style="text-align: left">Compare less or equal (e.g., 
<code>/ cell &amp; age &lt;= 1
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>&gt;
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.IsGreater">
<code>IsGreater
</code>
</a>
</td>
<td style="text-align: left">Compare greater than (e.g., 
<code>/ cell &amp; age &gt; 1
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>&gt;=
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.IsGreaterEqual">
<code>IsGreaterEqual
</code>
</a>
</td>
<td style="text-align: left">Compare greater or equal (e.g., 
<code>/ cell &amp; age &gt;= 1
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>~
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.IsMatch">
<code>IsMatch
</code>
</a>
</td>
<td style="text-align: left">Compare match (e.g., 
<code>/ gene &amp; name ~ RP\[SL\]
</code>).
</td>
</tr>
<tr>
<td style="text-align: left">
<code>!~
</code>
</td>
<td style="text-align: center">
<a href="queries.html#DataAxesFormats.Queries.IsNotMatch">
<code>IsNotMatch
</code>
</a>
</td>
<td style="text-align: left">Compare not match (e.g., 
<code>/ gene &amp; name !~ RP\[SL\]
</code>).
</td>
</tr>
</table>
<div class="admonition is-info" id="Note-d72ede13240aa928">
<header class="admonition-header">Note
<a class="admonition-anchor" href="#Note-d72ede13240aa928" title="Permalink">
</a>
</header>
<div class="admonition-body">
<p>Due to Julia&#39;s Documenter limitations, the ASCII 
<code>|
</code> character (
<code>&amp;#124;
</code>) is replaced by the Unicode 
<code>│
</code> character (
<code>&amp;#9474;
</code>) in the above table. Sigh.
</p>
</div>
</div>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.NAMES_QUERY">
<a class="docstring-binding" href="#DataAxesFormats.Queries.NAMES_QUERY">
<code>DataAxesFormats.Queries.NAMES_QUERY
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>NAMES_QUERY
</code> := ( 
<a href="queries.html#DataAxesFormats.Queries.Names">
<code>Names
</code>
</a> 
<code>scalars
</code> | 
<a href="queries.html#DataAxesFormats.Queries.Names">
<code>Names
</code>
</a> 
<code>axes
</code> | 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.Names">
<code>Names
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.Names">
<code>Names
</code>
</a> )
</p>
<p>A query returning a set of names:
</p>
<ul>
<li>Looking up the set of names of the scalar properties (
<code>? scalars
</code>).
</li>
<li>Looking up the set of names of the axes (
<code>? axes
</code>).
</li>
<li>Looking up the set of names of the vector properties of an axis (e.g., 
<code>/ cell ?
</code>).
</li>
<li>Looking up the set of names of the matrix properties of a pair of axes (e.g., 
<code>/ cell / gene ?
</code>).
</li>
</ul>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.SCALAR_QUERY">
<a class="docstring-binding" href="#DataAxesFormats.Queries.SCALAR_QUERY">
<code>DataAxesFormats.Queries.SCALAR_QUERY
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>SCALAR_QUERY
</code> := ( 
<code>LOOKUP_PROPERTY
</code>](@ref) | 
<a href="queries.html#DataAxesFormats.Queries.VECTOR_ENTRY">
<code>VECTOR_ENTRY
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.MATRIX_ENTRY">
<code>MATRIX_ENTRY
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.REDUCE_VECTOR">
<code>REDUCE_VECTOR
</code>
</a> ) 
<a href="registry.html#DataAxesFormats.Registry.EltwiseOperation">
<code>EltwiseOperation
</code>
</a>*
</p>
<p>A query returning a scalar can be one of:
</p>
<ul>
<li>Looking up the value of a scalar property (e.g., 
<code>: version
</code> will return the value of the version scalar property).
</li>
<li>Picking a single entry of a vector property (e.g., 
<code>/ gene = FOXP1 : is_marker
</code> will return whether the gene named FOXP1 is a marker gene).
</li>
<li>Picking a single entry of a matrix property (e.g., 
<code>/ gene = FOXP1 / cell = ATCG : UMIs
</code> will return the number of UMIs of the FOXP1 gene of the ATCG cell).
</li>
<li>Reducing some vector into a single value (e.g., 
<code>/ donor : age %&gt; Mean
</code> will compute the mean age of all the donors).
</li>
</ul>
<p>Either way, this can be followed by a series of 
<a href="registry.html#DataAxesFormats.Registry.EltwiseOperation">
<code>EltwiseOperation
</code>
</a> to modify the scalar result (e.g., 
<code>/ donor : age %&gt; Mean % Log base 2 % Abs
</code> will compute the absolute value of the log base 2 of the mean age of all the donors).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.LOOKUP_PROPERTY">
<a class="docstring-binding" href="#DataAxesFormats.Queries.LOOKUP_PROPERTY">
<code>DataAxesFormats.Queries.LOOKUP_PROPERTY
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>LOOKUP_PROPERTY
</code> := 
<a href="queries.html#DataAxesFormats.Queries.Lookup">
<code>Lookup
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>IfMissing
</code>
</a>?
</p>
<p>Lookup the value of a scalar or matrix property. This is used on its own to access a scalar property (e.g., 
<code>: version
</code>) or combined with two axes to access a matrix property (e.g., 
<code>/ cell / gene : UMIs
</code>).
</p>
<p>By default, it is an error if the property does not exist. However, if an 
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>IfMissing
</code>
</a> is provided, then this value is used instead (e.g., 
<code>: version || Unknown
</code> will return a 
<code>Unknown
</code> if there is no 
<code>version
</code> scalar property, and 
<code>/ cell / gene : UMIs || 0
</code> will return an all-zero matrix if there is no 
<code>UMIs
</code> matrix property).
</p>
<p>Accessing a 
<a href="queries.html#DataAxesFormats.Queries.VECTOR_PROPERTY">
<code>VECTOR_PROPERTY
</code>
</a> allows for more complex operations.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.VECTOR_ENTRY">
<a class="docstring-binding" href="#DataAxesFormats.Queries.VECTOR_ENTRY">
<code>DataAxesFormats.Queries.VECTOR_ENTRY
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>VECTOR_ENTRY
</code> := 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.IsEqual">
<code>IsEqual
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.VECTOR_LOOKUP">
<code>VECTOR_LOOKUP
</code>
</a>
</p>
<p>Lookup the scalar value of some entry of a vector property of some axis (e.g., 
<code>/ gene = FOXP1 : is_marker
</code> will return whether the FOXP1 gene is a marker gene).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.MATRIX_ENTRY">
<a class="docstring-binding" href="#DataAxesFormats.Queries.MATRIX_ENTRY">
<code>DataAxesFormats.Queries.MATRIX_ENTRY
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>MATRIX_ENTRY
</code> := 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.IsEqual">
<code>IsEqual
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.IsEqual">
<code>IsEqual
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.LOOKUP_PROPERTY">
<code>LOOKUP_PROPERTY
</code>
</a>
</p>
<p>Lookup the scalar value of the named entry of a matrix property (e.g., 
<code>/ gene = FOXP1 / cell = ATCG : UMIs
</code> will return the number of UMIs of the FOXP1 gene of the ATCG cell).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.REDUCE_VECTOR">
<a class="docstring-binding" href="#DataAxesFormats.Queries.REDUCE_VECTOR">
<code>DataAxesFormats.Queries.REDUCE_VECTOR
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>REDUCE
<em>VECTOR := [`VECTOR
</em>QUERY
<code>](@ref) [
</code>ReductionOperation
<code>](@ref) [
</code>IfMissing`](@ref)?
</p>
<p>Perform an arbitrary vector query, and reduce the result into a single scalar value (e.g., 
<code>/ donor : age %&gt; Mean
</code> will compute the mean age of the ages of the donors).
</p>
<p>By default, it is an error if the vector query results in an empty vector. However, if an 
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>IfMissing
</code>
</a> suffix is provided, then this value is used instead (e.g., 
<code>/ cell &amp; type = LMPP : age %&gt; Mean || 0
</code> will return zero if there are no cells whose type is LMPP).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.VECTOR_QUERY">
<a class="docstring-binding" href="#DataAxesFormats.Queries.VECTOR_QUERY">
<code>DataAxesFormats.Queries.VECTOR_QUERY
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>VECTOR_QUERY
</code> := ( 
<a href="queries.html#DataAxesFormats.Queries.VECTOR_PROPERTY">
<code>VECTOR_PROPERTY
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.MATRIX_ROW">
<code>MATRIX_ROW
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.MATRIX_COLUMN">
<code>MATRIX_COLUMN
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.REDUCE_MATRIX">
<code>REDUCE_MATRIX
</code>
</a> ) 
<a href="queries.html#DataAxesFormats.Queries.POST_PROCESS">
<code>POST_PROCESS
</code>
</a>*
</p>
<p>A query returning a vector can be one of:
</p>
<ul>
<li>Looking up the value of a vector property (e.g., 
<code>/ gene : is_marker
</code> will return a mask of the marker genes).
</li>
<li>Picking a single row or column of a matrix property (e.g., 
<code>/ gene = FOXP1 / cell : UMIs
</code> will return a vector of the UMIs of the FOXP1 gene of all the cells).
</li>
<li>Reducing each column of some matrix into a scalar, resulting in a vector (e.g., 
<code>/ gene / cell : UMIs %&gt; Sum
</code> will compute the sum of the UMIs of all the genes in each cell).
</li>
</ul>
<p>Either way, this can be followed by further processing of the vector (e.g., 
<code>/ gene / cell : UMIs % Log base 2 eps 1
</code> will compute the log base 2 of one plus the of the UMIs of each gene in each cell).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.VECTOR_PROPERTY">
<a class="docstring-binding" href="#DataAxesFormats.Queries.VECTOR_PROPERTY">
<code>DataAxesFormats.Queries.VECTOR_PROPERTY
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>VECTOR_PROPERTY
</code> := 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.AXIS_MASK">
<code>AXIS_MASK
</code>
</a>* 
<a href="queries.html#DataAxesFormats.Queries.VECTOR_LOOKUP">
<code>VECTOR_LOOKUP
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.VECTOR_FETCH">
<code>VECTOR_FETCH
</code>
</a>*
</p>
<p>Lookup the values of some vector property (e.g., 
<code>/ gene : is_marker
</code> will return a mask of the marker genes). This can be restricted to a subset of the vector using masks (e.g., 
<code>/ gene &amp; is_marker : is_noisy
</code> will return a mask of the noisy genes out of the marker genes), and/or fetch the property value from indirect axes (e.g., 
<code>/ cell : batch =&gt; donor =&gt; age
</code> will return the age of the donor of the batch of each cell).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.VECTOR_LOOKUP">
<a class="docstring-binding" href="#DataAxesFormats.Queries.VECTOR_LOOKUP">
<code>DataAxesFormats.Queries.VECTOR_LOOKUP
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>VECTOR_LOOKUP
</code> := 
<a href="queries.html#DataAxesFormats.Queries.Lookup">
<code>Lookup
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>IfMissing
</code>
</a>? ( 
<a href="queries.html#DataAxesFormats.Queries.IfNot">
<code>IfNot
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.AsAxis">
<code>AsAxis
</code>
</a> )?
</p>
<p>A 
<a href="queries.html#DataAxesFormats.Queries.Lookup">
<code>Lookup
</code>
</a> of a vector property (e.g., 
<code>/ cell : type
</code> will return the type of each cell).
</p>
<p>By default, it is an error if the property does not exist. However, if an 
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>IfMissing
</code>
</a> is provided, then this value is used instead (e.g., 
<code>/ cell : type || Unknown
</code> will return a vector of 
<code>Unknown
</code> types if there is no 
<code>type
</code> property for the 
<code>cell
</code> axis).
</p>
<p>If the 
<a href="queries.html#DataAxesFormats.Queries.IfNot">
<code>IfNot
</code>
</a> suffix is provided, it controls how to modify &quot;false-ish&quot; (empty string, zero numeric value, or false Boolean value) entries (e.g., 
<code>/ cell : type ?
</code> will return a vector of the type of each cell that has a non-empty type, while 
<code>/ cell : type ? Outlier
</code> will return a vector of the type of each cell, where cells with an empty type are given  the type 
<code>Outlier
</code>).
</p>
<p>Only when the vector property is used for 
<a href="queries.html#DataAxesFormats.Queries.CountBy">
<code>CountBy
</code>
</a> or for 
<a href="queries.html#DataAxesFormats.Queries.GroupBy">
<code>GroupBy
</code>
</a>, providing the 
<a href="queries.html#DataAxesFormats.Queries.AsAxis">
<code>AsAxis
</code>
</a> suffix indicates that the property is associated with an axis (similar to an indirect axis in 
<a href="queries.html#DataAxesFormats.Queries.Fetch">
<code>Fetch
</code>
</a>), and the set of groups is forced to be the values of that axis; in this case, empty string values are always ignored (e.g., 
<code>/ cell : age @ type ! %&gt; Mean || 0
</code> will return a vector of the mean age of the cells of each type, with a value of zero for types which have no cells, and ignoring cells which have an empty type; similarly, 
<code>/ cell : batch =&gt; donor ! * type !
</code> will return a matrix whose rows are donors and columns are types, counting the number of cells of each type that were sampled from each donor, ignoring cells which have an empty type or whose batch has an empty donor).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.MATRIX_ROW">
<a class="docstring-binding" href="#DataAxesFormats.Queries.MATRIX_ROW">
<code>DataAxesFormats.Queries.MATRIX_ROW
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>MATRIX_ROW
</code> := 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.IsEqual">
<code>IsEqual
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.AXIS_MASK">
<code>AXIS_MASK
</code>
</a>* 
<a href="queries.html#DataAxesFormats.Queries.Lookup">
<code>Lookup
</code>
</a>
</p>
<p>Lookup the values of a single row of a matrix property, eliminating the rows axis (e.g., 
<code>/ gene = FOXP1 / cell : UMIs
</code> will evaluate to a vector of the UMIs of the FOXP1 gene of all the cells).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.MATRIX_COLUMN">
<a class="docstring-binding" href="#DataAxesFormats.Queries.MATRIX_COLUMN">
<code>DataAxesFormats.Queries.MATRIX_COLUMN
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>MATRIX_COLUMN
</code> := 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.AXIS_MASK">
<code>AXIS_MASK
</code>
</a>* 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.IsEqual">
<code>IsEqual
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.Lookup">
<code>Lookup
</code>
</a>
</p>
<p>Lookup the values of a single column of a matrix property, eliminating the columns axis (e.g., 
<code>/ gene / cell = ATCG : UMIs
</code> will evaluate to a vector of the UMIs of all the genes of the ATCG cell).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.REDUCE_MATRIX">
<a class="docstring-binding" href="#DataAxesFormats.Queries.REDUCE_MATRIX">
<code>DataAxesFormats.Queries.REDUCE_MATRIX
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>REDUCE_MATRIX
</code> := 
<a href="queries.html#DataAxesFormats.Queries.MATRIX_QUERY">
<code>MATRIX_QUERY
</code>
</a> 
<a href="registry.html#DataAxesFormats.Registry.ReductionOperation">
<code>ReductionOperation
</code>
</a>
</p>
<p>Perform an arbitrary matrix query, and reduce the result into a vector by converting each column into a single value, eliminating the rows axis (e.g., 
<code>/ gene / cell : UMIs %&gt; Sum
</code> will evaluate to a vector of the total UMIs of each cell).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.MATRIX_QUERY">
<a class="docstring-binding" href="#DataAxesFormats.Queries.MATRIX_QUERY">
<code>DataAxesFormats.Queries.MATRIX_QUERY
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>MATRIX_QUERY
</code> := ( 
<a href="queries.html#DataAxesFormats.Queries.MATRIX_LOOKUP">
<code>MATRIX_LOOKUP
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.COUNTS_MATRIX">
<code>COUNTS_MATRIX
</code>
</a> ) 
<a href="queries.html#DataAxesFormats.Queries.POST_PROCESS">
<code>POST_PROCESS
</code>
</a>*
</p>
<p>A query returning a matrix can be one of:
</p>
<ul>
<li>Looking up the value of a matrix property (e.g., 
<code>/ gene / cell : UMIs
</code> will return the matrix of UMIs for each gene and cell).
</li>
<li>Counting the number of times each combination of two vector properties occurs in the data (e.g., 
<code>/ cell : batch =&gt; donor =&gt; age * type
</code> will return a matrix whose rows are ages and columns are types, where each entry contains the number of cells which have the specific type and age).
</li>
</ul>
<p>Either way, this can be followed by a series of 
<a href="registry.html#DataAxesFormats.Registry.EltwiseOperation">
<code>EltwiseOperation
</code>
</a> to modify the results (e.g., 
<code>/ gene / cell : UMIs % Log base 2 eps 1
</code> will compute the log base 2 of 1 plus the UMIs of each gene in each cell).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.MATRIX_LOOKUP">
<a class="docstring-binding" href="#DataAxesFormats.Queries.MATRIX_LOOKUP">
<code>DataAxesFormats.Queries.MATRIX_LOOKUP
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>MATRIX_LOOKUP
</code> := 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.AXIS_MASK">
<code>AXIS_MASK
</code>
</a>* 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.AXIS_MASK">
<code>AXIS_MASK
</code>
</a>* 
<a href="queries.html#DataAxesFormats.Queries.Lookup">
<code>Lookup
</code>
</a>
</p>
<p>Lookup the values of some matrix property (e.g., 
<code>/ gene / cell : UMIs
</code> will return the matrix of UMIs of each gene in each cell). This can be restricted to a subset of the vector using masks (e.g., 
<code>/ gene &amp; is_marker / cell &amp; type = LMPP : UMIs
</code> will return a matrix of the UMIs of each marker gene in cells whose type is LMPP).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.COUNTS_MATRIX">
<a class="docstring-binding" href="#DataAxesFormats.Queries.COUNTS_MATRIX">
<code>DataAxesFormats.Queries.COUNTS_MATRIX
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>COUNTS_MATRIX
</code> := 
<a href="queries.html#DataAxesFormats.Queries.VECTOR_QUERY">
<code>VECTOR_QUERY
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.CountBy">
<code>CountBy
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.VECTOR_FETCH">
<code>VECTOR_FETCH
</code>
</a>*
</p>
<p>Compute a matrix of counts of each combination of values given two vectors (e.g., 
<code>/ cell : batch =&gt; donor =&gt; age * batch =&gt; donor =&gt; sex
</code> will return a matrix whose rows are ages and columns are sexes, where each entry contains the number of cells which have the specific age and sex).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.POST_PROCESS">
<a class="docstring-binding" href="#DataAxesFormats.Queries.POST_PROCESS">
<code>DataAxesFormats.Queries.POST_PROCESS
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>POST_PROCESS
</code> := 
<a href="registry.html#DataAxesFormats.Registry.EltwiseOperation">
<code>EltwiseOperation
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.GROUP_BY">
<code>GROUP_BY
</code>
</a>
</p>
<p>A vector or a matrix result may be processed by one of:
</p>
<ul>
<li>Applying an 
<a href="registry.html#DataAxesFormats.Registry.EltwiseOperation">
<code>EltwiseOperation
</code>
</a> operation to each value (e.g., 
<code>/ donor : age % Log base 2
</code> will compute the log base 2 of the ages of all donors, and 
<code>/ gene / cell : UMIs % Log base 2 eps 1
</code> will compute the log base 2 of 1 plus the UMIs count of each gene in each cell).
</li>
<li>Reducing each group of vector entries or matrix rows into a single value (e.g., 
<code>/ cell : batch =&gt; donor =&gt; age @ type %&gt; Mean
</code> will compute a vector of the mean age of the cells of each type, and 
<code>/ cell / gene : UMIs @ type %&gt; Mean
</code> will compute a matrix of the mean UMIs of each gene for the cells of each type).
</li>
</ul>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.GROUP_BY">
<a class="docstring-binding" href="#DataAxesFormats.Queries.GROUP_BY">
<code>DataAxesFormats.Queries.GROUP_BY
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>GROUP_BY
</code> := 
<a href="queries.html#DataAxesFormats.Queries.GroupBy">
<code>GroupBy
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.VECTOR_FETCH">
<code>VECTOR_FETCH
</code>
</a>* 
<a href="registry.html#DataAxesFormats.Registry.ReductionOperation">
<code>ReductionOperation
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>IfMissing
</code>
</a>
</p>
<p>The entries of a vector or the rows of a matrix result may be grouped, where all the values that have the same group value are reduced to a single value using a 
<a href="registry.html#DataAxesFormats.Registry.ReductionOperation">
<code>ReductionOperation
</code>
</a> (e.g., 
<code>/ cell : batch =&gt; donor =&gt; age @ type %&gt; Mean
</code> will compute the mean age of all the cells of each type, and 
<code>/ cell / gene : UMIs @ type %&gt; Mean
</code> will compute a matrix of the mean UMIs of each gene for the cells of each type).
</p>
<p>If the group property is suffixed by 
<a href="queries.html#DataAxesFormats.Queries.AsAxis">
<code>AsAxis
</code>
</a>, then the result will have a value for each entry of the axis (e.g., 
<code>/ cell : age @ type ! %&gt; Mean
</code> will compute the mean age of the cells of each type). In this case, some groups may have no values at all, which by default, is an error. Providing an 
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>IfMissing
</code>
</a> suffix will use the specified value for such empty groups instead (e.g., 
<code>/ cell : age @ type ! %&gt; Mean || 0
</code> will compute the mean age for the cells of each type, with a zero value for types for which there are no cells).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.AXIS_MASK">
<a class="docstring-binding" href="#DataAxesFormats.Queries.AXIS_MASK">
<code>DataAxesFormats.Queries.AXIS_MASK
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>AXIS_MASK
</code> := 
<a href="queries.html#DataAxesFormats.Queries.MASK_OPERATION">
<code>MASK_OPERATION
</code>
</a> ( 
<a href="queries.html#DataAxesFormats.Queries.VECTOR_FETCH">
<code>VECTOR_FETCH
</code>
</a> )* ( 
<a href="queries.html#DataAxesFormats.Queries.MASK_SLICE">
<code>MASK_SLICE
</code>
</a> )? ( 
<a href="queries.html#DataAxesFormats.Queries.ComparisonOperation">
<code>ComparisonOperation
</code>
</a> )?
</p>
<p>Restrict the set of entries of an axis to lookup results for (e.g., 
<code>/ gene &amp; is_marker
</code>). If the mask is based on a non-
<code>Bool
</code> property, it is converted to a Boolean by comparing with the empty string or a zero value (depending on its data type); alternatively, you can explicitly compare it with a value (e.g., 
<code>/ cell &amp; batch =&gt; donor =&gt; age &gt; 1
</code>).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.MASK_OPERATION">
<a class="docstring-binding" href="#DataAxesFormats.Queries.MASK_OPERATION">
<code>DataAxesFormats.Queries.MASK_OPERATION
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>MASK_OPERATION
</code> := 
<a href="queries.html#DataAxesFormats.Queries.And">
<code>And
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.AndNot">
<code>AndNot
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.Or">
<code>Or
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.OrNot">
<code>OrNot
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.Xor">
<code>Xor
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.XorNot">
<code>XorNot
</code>
</a>
</p>
<p>A query operation for restricting the set of entries of an 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a>. The mask operations are applied to the current mask, so if several operations are applied, they are applied in order from left to right (e.g., 
<code>/ gene &amp; is_marker | is_noisy &amp;! is_lateral
</code> will first restrict the set of genes to marker genes, then expand it to include noisy genes as well, then remove all the lateral genes; this would be different from 
<code>/ gene &amp; is_marker &amp;! is_lateral | is_noisy
</code>, which will include all noisy genes even if they are lateral).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.MASK_SLICE">
<a class="docstring-binding" href="#DataAxesFormats.Queries.MASK_SLICE">
<code>DataAxesFormats.Queries.MASK_SLICE
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>MASK_SLICE
</code> := 
<a href="queries.html#DataAxesFormats.Queries.MaskSlice">
<code>MaskSlice
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.IsEqual">
<code>IsEqual
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.SquareMaskColumn">
<code>SquareMaskColumn
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.SquareMaskRow">
<code>SquareMaskRow
</code>
</a>
</p>
<p>Allow using a row or a column of a matrix as a mask. If the matrix uses a different axis, then use 
<a href="queries.html#DataAxesFormats.Queries.MaskSlice">
<code>MaskSlice
</code>
</a> to specify the axis followed by 
<a href="queries.html#DataAxesFormats.Queries.IsEqual">
<code>IsEqual
</code>
</a> to specify the slice to use (e.g., 
<code>/ cell &amp; UMIs ; gene &gt; 0
</code>). If the matrix is square use 
<a href="queries.html#DataAxesFormats.Queries.SquareMaskColumn">
<code>SquareMaskColumn
</code>
</a> or 
<a href="queries.html#DataAxesFormats.Queries.SquareMaskRow">
<code>SquareMaskRow
</code>
</a> to slice a column or a row of the matrix (e.g., 
<code>/ cell &amp; outgoing ;= ATCG
</code> or 
<code>/ cell &amp; outgoing ,= ATCG
</code>).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.VECTOR_FETCH">
<a class="docstring-binding" href="#DataAxesFormats.Queries.VECTOR_FETCH">
<code>DataAxesFormats.Queries.VECTOR_FETCH
</code>
</a> — 
<span class="docstring-category">Constant
</span>
</summary>
<section>
<div>
<p>
<code>VECTOR_FETCH
</code> := 
<a href="queries.html#DataAxesFormats.Queries.AsAxis">
<code>AsAxis
</code>
</a>? 
<a href="queries.html#DataAxesFormats.Queries.Fetch">
<code>Fetch
</code>
</a> 
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>IfMissing
</code>
</a>? ( 
<a href="queries.html#DataAxesFormats.Queries.IfNot">
<code>IfNot
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.AsAxis">
<code>AsAxis
</code>
</a> )?
</p>
<p>Fetch the value of a property of an indirect axis. That is, there is a common pattern where one axis (e.g., cell) has a property (e.g., type) which has the same name as an axis, and whose values are (string) entry names of that axis. In this case, we often want to lookup a property of the other axis (e.g., 
<code>/ cell : type =&gt; color
</code> will evaluate to a vector of the color of the type of each cell). Sometimes one walks a chain of such properties (e.g., 
<code>/ cell : batch =&gt; donor =&gt; age
</code>).
</p>
<p>Sometimes it is needed to store several alternate properties that refer to the same indirect axis. In this case, the name of the property can begin with the axis name, followed by 
<code>.
</code> and a suffix (e.g., 
<code>/ cell : type.manual =&gt; color
</code> will fetch the color of the manual type of each cell, still using the type axis).
</p>
<p>If the property does not follow this convention, it is possible to manually specify the name of the axis using an 
<a href="queries.html#DataAxesFormats.Queries.AsAxis">
<code>AsAxis
</code>
</a> prefix (e.g., 
<code>/ cell : manual ! type =&gt; color
</code> will assume the value of the 
<code>manual
</code> property is a vector of names of entries of the 
<code>type
</code> axis).
</p>
<p>As usual, if the property does not exist, this is an error, unless an 
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>IfMissing
</code>
</a> suffix is provided (e.g., 
<code>/ cell : type || red =&gt; color
</code> will assign all cells the color 
<code>red
</code> if the 
<code>type
</code> property does not exist).
</p>
<p>If the value of the property is the empty string for some vector entries, by default this is again an error (as the empty string is not one of the values of the indirect axis). If an 
<a href="queries.html#DataAxesFormats.Queries.IfNot">
<code>IfNot
</code>
</a> suffix is provided, such entries can be removed from the result (e.g., 
<code>/ cell : type ? =&gt; color
</code> will return a vector of the colors of the cells which have a non-empty type), or can be given an specific value (e.g., 
<code>/ cell : type ? red =&gt; color
</code> will return a vector of a color for each cell, giving the 
<code>red
</code> color to cells with an empty type).
</p>
<p>When using 
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>IfMissing
</code>
</a> and/or 
<a href="queries.html#DataAxesFormats.Queries.IfNot">
<code>IfNot
</code>
</a>, the default value provided is always of the final value (e.g., 
<code>/ cell : batch || -1 ? -2 =&gt; donor || -3 ? -4 =&gt; age || -5 ? -6
</code> will compute a vector if age per cell; if there&#39;s no 
<code>batch
</code> property, all cells will get the age 
<code>-1
</code>). If there is such property, then cells with an empty batch will get the age 
<code>-2
</code>. For cells with a non-empty batch, if there&#39;s no 
<code>donor
</code> property, they will get the value 
<code>-3
</code>. If there is such a property, cells with an empty donor will get the value 
<code>-4
</code>. Finally, for cells with a batch and donor, if there is no 
<code>age
</code> property, they will be given an age of 
<code>-5
</code>. Otherwise, if their age is zero, it will be changed to 
<code>-6
</code>.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.guess_typed_value">
<a class="docstring-binding" href="#DataAxesFormats.Queries.guess_typed_value">
<code>DataAxesFormats.Queries.guess_typed_value
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">guess_typed_value(value::AbstractString)::StorageScalar
</code>
</pre>
<p>Given a string value, guess the typed value it represents:
</p>
<ul>
<li>
<code>true
</code> and 
<code>false
</code> are assumed to be 
<code>Bool
</code>.
</li>
<li>Integers are assumed to be 
<code>Int64
</code>.
</li>
<li>Floating point numbers are assumed to be 
<code>Float64
</code>, as are 
<code>e
</code> and 
<code>pi
</code>.
</li>
<li>Anything else is assumed to be a string.
</li>
</ul>
<p>This doesn&#39;t have to be 100% accurate; it is intended to allow omitting the data type in most cases when specifying an 
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>IfMissing
</code>
</a> value. If it guesses wrong, just specify an explicit type (e.g., 
<code>@ version || 1.0 String
</code>).
</p>
</div>
</section>
</details>
</article>
<h2 id="Query-Operators">
<a class="docs-heading-anchor" href="#Query-Operators">Query Operators
</a>
<a id="Query-Operators-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Query-Operators" title="Permalink">
</a>
</h2>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.QuerySequence">
<a class="docstring-binding" href="#DataAxesFormats.Queries.QuerySequence">
<code>DataAxesFormats.Queries.QuerySequence
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">struct QuerySequence{N} &lt;: Query where {N&lt;:Integer}
</code>
</pre>
<p>A sequence of 
<code>N
</code> 
<a href="registry.html#DataAxesFormats.Registry.QueryOperation">
<code>QueryOperation
</code>
</a>s. This is the internal representation of the query as of itself (without applying it).
</p>
</div>
</section>
</details>
</article>
<h3 id="Data-Operators">
<a class="docs-heading-anchor" href="#Data-Operators">Data Operators
</a>
<a id="Data-Operators-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Data-Operators" title="Permalink">
</a>
</h3>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.AsAxis">
<a class="docstring-binding" href="#DataAxesFormats.Queries.AsAxis">
<code>DataAxesFormats.Queries.AsAxis
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">AsAxis([axis::AbstractString = nothing]) &lt;: QueryOperation
</code>
</pre>
<p>There are three cases where we may want to take a vector property and consider each value to be the name of an entry of some axis: 
<a href="queries.html#DataAxesFormats.Queries.Fetch">
<code>Fetch
</code>
</a>, 
<a href="queries.html#DataAxesFormats.Queries.CountBy">
<code>CountBy
</code>
</a> and 
<a href="queries.html#DataAxesFormats.Queries.GroupBy">
<code>GroupBy
</code>
</a>. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is indicated by the 
<code>!
</code> operators, optionally followed by the name of the axis to use.
</p>
<p>When using 
<a href="queries.html#DataAxesFormats.Queries.Fetch">
<code>Fetch
</code>
</a>, we always lookup in some axis, so 
<a href="queries.html#DataAxesFormats.Queries.AsAxis">
<code>AsAxis
</code>
</a> is implied (e.g., 
<code>/ cell : type =&gt; color
</code> is identical to 
<code>/ cell : type ! =&gt; color
</code>). In contrast, when using 
<a href="queries.html#DataAxesFormats.Queries.CountBy">
<code>CountBy
</code>
</a> and 
<a href="queries.html#DataAxesFormats.Queries.GroupBy">
<code>GroupBy
</code>
</a>, one has to explicitly specify 
<code>AsAxis
</code> to force using all the entries of the axis for the counting or grouping (e.g., 
<code>/ cell : age @ type %&gt; Mean
</code> will return a vector of the mean age of every type that has cells associated with it, while 
<code>/ cell : age @ type ! %&gt; Mean
</code> will return a vector of the mean age of each and every value of the type axis; similarly, 
<code>/ cell : type * age
</code> will generate a counts matrix whose rows are types that have cells associated with them, while 
<code>/ cell : type ! * age
</code> will generate a counts matrix whose rows are exactly the entries of the type axis).
</p>
<p>Since the set of values is fixed by the axis matching the vector property, it is possible that, when using this for 
<a href="queries.html#DataAxesFormats.Queries.GroupBy">
<code>GroupBy
</code>
</a>, some groups would have no values, causing an error. This can be avoided by providing an 
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>IfMissing
</code>
</a> suffix to the reduction (e.g., 
<code>/ cell : age @ type ! %&gt; Mean
</code> will fail if some type has no cells associated with it, while 
<code>/ cell : age @ type ! %&gt; Mean || 0
</code> will give such types a zero mean age).
</p>
<p>Typically, the name of the base property is identical to the name of the axis. In this case, there is no need to specify the name of the axis (as in the examples above). Sometimes it is useful to be able to store several vector properties which all map to the same axis. To support this, we support a naming convention where the property name begins with the axis name followed by a 
<code>.suffix
</code>. (e.g., both 
<code>/ cell : type =&gt; color
</code> and 
<code>/ cell : type.manual =&gt; color
</code> will look up the 
<code>color
</code> of the 
<code>type
</code> of some property of the 
<code>cell
</code> axis - either &quot;the&quot; 
<code>type
</code> of each 
<code>cell
</code>, or the alternate 
<code>type.manual
</code> of each cell).
</p>
<p>If the property name does not follow the above conventions, then it is possible to explicitly specify the name of the axis (e.g., 
<code>/ cell : manual ! type =&gt; color
</code> will consider each value of the 
<code>manual
</code> property as the name of an entry of the 
<code>type
</code> axis and look up the matching 
<code>color
</code> property value of this axis).
</p>
<pre>
<code class="language-julia hljs">metacells = example_metacells_daf()
type_per_metacell = metacells[&quot;/ metacell : type&quot;]
set_vector!(metacells, &quot;metacell&quot;, &quot;kind&quot;, reverse(type_per_metacell.array))

# Axis(&quot;metacell&quot;) |&gt; Lookup(&quot;kind&quot;) |&gt; AsAxis(&quot;type&quot;) |&gt; Fetch(&quot;color&quot;) |&gt; get_query(metacells)
metacells[&quot;/ metacell : kind ! type =&gt; color&quot;]

# output

7-element Named SparseArrays.ReadOnly{String, 1, Vector{String}}
metacell  │
──────────┼────────────
M1671.28  │ &quot;steelblue&quot;
M2357.20  │   &quot;#eebb6e&quot;
M2169.56  │      &quot;gold&quot;
M2576.86  │   &quot;#eebb6e&quot;
M1440.15  │      &quot;plum&quot;
M756.63   │      &quot;gold&quot;
M412.08   │      &quot;gold&quot;
</code>
</pre>
<pre>
<code class="language-julia hljs">chain = example_chain_daf()
type_per_metacell = chain[&quot;/ metacell : type&quot;]
set_vector!(chain, &quot;metacell&quot;, &quot;kind&quot;, reverse(type_per_metacell.array))

# Axis(&quot;cell&quot;) |&gt; Lookup(&quot;donor&quot;) |&gt; Fetch(&quot;age&quot;) |&gt; GroupBy(&quot;kind&quot;) |&gt; IfNot() |&gt; AsType(&quot;type&quot;) |&gt; Mean() |&gt; get_query(chain)
chain[&quot;/ cell : donor =&gt; age @ metacell ?? =&gt; kind ! type %&gt; Mean&quot;]

# output

4-element Named SparseArrays.ReadOnly{Float32, 1, Vector{Float32}}
type     │
─────────┼────────
MEBEMP-E │ 64.5693
MEBEMP-L │ 66.0219
MPP      │ 62.7153
memory-B │ 62.2593
</code>
</pre>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.Axis">
<a class="docstring-binding" href="#DataAxesFormats.Queries.Axis">
<code>DataAxesFormats.Queries.Axis
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">Axis(axis::AbstractString) &lt;: QueryOperation
</code>
</pre>
<p>A query operation for specifying a result axis. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is specified using the 
<code>/
</code> operator followed by the axis name.
</p>
<p>This needs to be specified at least once for a vector query (e.g., 
<code>/ cell : batch
</code>), and twice for a matrix (e.g., 
<code>/ cell / gene : UMIs
</code>). Axes can be filtered using Boolean masks using 
<a href="queries.html#DataAxesFormats.Queries.And">
<code>And
</code>
</a>, 
<a href="queries.html#DataAxesFormats.Queries.AndNot">
<code>AndNot
</code>
</a>, 
<a href="queries.html#DataAxesFormats.Queries.Or">
<code>Or
</code>
</a>, 
<a href="queries.html#DataAxesFormats.Queries.OrNot">
<code>OrNot
</code>
</a>, 
<a href="queries.html#DataAxesFormats.Queries.Xor">
<code>Xor
</code>
</a> and 
<a href="queries.html#DataAxesFormats.Queries.XorNot">
<code>XorNot
</code>
</a> (e.g., 
<code>/ gene &amp; is_marker : is_noisy
</code>). Alternatively, a single entry can be selected from the axis using 
<a href="queries.html#DataAxesFormats.Queries.IsEqual">
<code>IsEqual
</code>
</a> (e.g., 
<code>/ gene = FOXP1 : is_noisy
</code>, 
<code>/ cell / gene = FOXP1 : UMIs
</code>, 
<code>/ cell = C1 / gene = FOXP1 : UMIs
</code>). Finally, a matrix can be reduced into a vector, and a vector to a scalar, using 
<a href="registry.html#DataAxesFormats.Registry.ReductionOperation">
<code>ReductionOperation
</code>
</a> (e.g., 
<code>/ gene / cell : UMIs %&gt; Sum %&gt; Mean
</code>).
</p>
<div class="admonition is-info" id="Note-5e8fbaf2a8ee9707">
<header class="admonition-header">Note
<a class="admonition-anchor" href="#Note-5e8fbaf2a8ee9707" title="Permalink">
</a>
</header>
<div class="admonition-body">
<p>This, 
<a href="queries.html#DataAxesFormats.Queries.Names">
<code>Names
</code>
</a> and 
<a href="queries.html#DataAxesFormats.Queries.Lookup">
<code>Lookup
</code>
</a> are the only 
<a href="registry.html#DataAxesFormats.Registry.QueryOperation">
<code>QueryOperation
</code>
</a>s that also works as a complete 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>.
</p>
</div>
</div>
<pre>
<code class="language-julia hljs">metacells = example_metacells_daf()
println(String.(Axis(&quot;metacell&quot;) |&gt; get_query(metacells)))
println(String.(metacells[&quot;/ metacell&quot;]))

# output

[&quot;M1671.28&quot;, &quot;M2357.20&quot;, &quot;M2169.56&quot;, &quot;M2576.86&quot;, &quot;M1440.15&quot;, &quot;M756.63&quot;, &quot;M412.08&quot;]
[&quot;M1671.28&quot;, &quot;M2357.20&quot;, &quot;M2169.56&quot;, &quot;M2576.86&quot;, &quot;M1440.15&quot;, &quot;M756.63&quot;, &quot;M412.08&quot;]
</code>
</pre>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.CountBy">
<a class="docstring-binding" href="#DataAxesFormats.Queries.CountBy">
<code>DataAxesFormats.Queries.CountBy
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">CountBy(property::AbstractString) &lt;: QueryOperation
</code>
</pre>
<p>A query operation that generates a matrix of counts of combinations of pairs of values for the same entries of an axis. That is, it follows fetching some vector property, and is followed by fetching a second vector property of the same axis. The result is a matrix whose rows are the values of the 1st property and the columns are the values of the 2nd property, and the values are the number of times the combination of values appears. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is specified using the 
<code>*
</code> operator, followed by the property name to look up (e.g., 
<code>/ cell : type * batch
</code> will generate a matrix whose rows correspond to cell types, whose columns correspond to cell batches, and whose values are the number of cells of each combination of batch and type).
</p>
<p>By default, the rows and/or columns only contain actually seen values and are ordered alphabetically. However, it is common that one or both of the properties correspond to an axis. In this case, you can use an 
<a href="queries.html#DataAxesFormats.Queries.AsAxis">
<code>AsAxis
</code>
</a> suffix to force the rows and/or columns of the matrix to be exactly the entries of the specific axis (e.g., 
<code>/ cell : type ! * batch
</code> will generate a matrix whose rows are exactly the entries of the 
<code>type
</code> axis, even if there is a type without any cells). This is especially useful when both properties are axes, as the result can be stored as a matrix property (e.g., 
<code>/ cell : type ! * batch !
</code> will generate a matrix whose rows are the entries of the type axis, and whose columns are the entries of the batch axis, so it can be given to 
<code>set_matrix!(daf, &quot;type&quot;, &quot;batch&quot;, ...)
</code>).
</p>
<p>The raw counts matrix can be post-processed like any other matrix (using 
<a href="registry.html#DataAxesFormats.Registry.ReductionOperation">
<code>ReductionOperation
</code>
</a> or an 
<a href="registry.html#DataAxesFormats.Registry.EltwiseOperation">
<code>EltwiseOperation
</code>
</a>). This allows computing useful aggregate properties (e.g., 
<code>/ cell : type * batch % Fractions
</code> will generate a matrix whose columns correspond to batches and whose rows are the fraction of the cells from each type within each batch).
</p>
<pre>
<code class="language-julia hljs">chain = example_chain_daf()

# Axis(&quot;cell&quot;) |&gt; Lookup(&quot;donor&quot;) |&gt; CountBy(&quot;metacell&quot;) |&gt; IfNot(&quot;Outlier&quot;) |&gt; Fetch(&quot;type&quot;) |&gt; Convert(type = Int) |&gt; get_query(chain)
chain[&quot;/ cell : donor * metacell ?? Outlier =&gt; type % Convert type Int&quot;]

# output

95×5 Named SparseArrays.ReadOnly{Int64, 2, Matrix{Int64}}
donor ╲ type │ MEBEMP-E  MEBEMP-L       MPP   Outlier  memory-B
─────────────┼─────────────────────────────────────────────────
N100         │        2         2         8         0         2
N101         │        0         1         6         0         9
N102         │        4         0         3         0         0
N103         │        4         2         2         0         2
N104         │        2         2         3         0        27
N105         │        3         1         1         0         4
N106         │        3         1         7         0         2
N107         │        2         1         4         0         7
⋮                     ⋮         ⋮         ⋮         ⋮         ⋮
N92          │        4         0         2         0         0
N93          │        0         1         0         0         2
N94          │        5         1         2         0         3
N95          │        2         0         3         0         0
N96          │        6         2        12         0         1
N97          │        0         2         2         0         1
N98          │        2         0         4         0         0
N99          │        4         0         7         0        16
</code>
</pre>
<div class="admonition is-info" id="Note-bb2da60e8dd5ad15">
<header class="admonition-header">Note
<a class="admonition-anchor" href="#Note-bb2da60e8dd5ad15" title="Permalink">
</a>
</header>
<div class="admonition-body">
<p>We use unsigned integers for values-that-can&#39;t-be-negative in 
<code>Daf
</code> so that trying to feed negative data into such places will be an error as soon as possible. However, Julia in its infinite wisdom prints unsigned ints in hexadecimal, which is an abomination. In the example above we convert the result to 
<code>Int
</code> so it will be displayed properly; in actual code this step should be avoided.
</p>
</div>
</div>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.Fetch">
<a class="docstring-binding" href="#DataAxesFormats.Queries.Fetch">
<code>DataAxesFormats.Queries.Fetch
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">Fetch(property::AbstractString) &lt;: QueryOperation
</code>
</pre>
<p>A query operation for fetching the value of a property from another axis, based on a vector property whose values are entry names of the axis. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is specified using the 
<code>=&gt;
</code> operator, followed by the name to look up.
</p>
<p>That is, if you query for the values of a vector property (e.g., 
<code>batch
</code> for each 
<code>cell
</code>), and the name of this property is identical to some axis name, then we assume each value is the name of an entry of this axis. We use this to fetch the value of some other property (e.g., 
<code>age
</code>) of that axis (e.g., 
<code>/ cell : batch =&gt; age
</code>).
</p>
<p>It is useful to be able to store several vector properties which all map to the same axis. To support this, we support a naming convention where the property name begins with the axis name followed by a 
<code>.suffix
</code>. (e.g., both 
<code>/ cell : type =&gt; color
</code> and 
<code>/ cell : type.manual =&gt; color
</code> will look up the 
<code>color
</code> of the 
<code>type
</code> of some property of the 
<code>cell
</code> axis - either &quot;the&quot; 
<code>type
</code> of each 
<code>cell
</code>, or the alternate 
<code>type.manual
</code> of each cell).
</p>
<p>Fetching can be chained (e.g., 
<code>/ cell : batch =&gt; donor =&gt; age
</code> will fetch the 
<code>age
</code> of the 
<code>donor
</code> of the 
<code>batch
</code> of each 
<code>cell
</code>).
</p>
<p>If the property does not exist, this is an error, unless this is followed by 
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>IfMissing
</code>
</a> (e.g., 
<code>/ cell : type =&gt; color || red
</code>). If the property contains an empty value, this is also an error, unless it is followed by an 
<a href="queries.html#DataAxesFormats.Queries.IfNot">
<code>IfNot
</code>
</a> (e.g., 
<code>/ cell : type ? =&gt; color
</code> will compute a vector of the colors of the type of the cells that have a non-empty type, and 
<code>/ cell : batch ? 0 =&gt; donor =&gt; age
</code> will assign a zero age for cells which have an empty batch).
</p>
<p>If the property exists but contains empty values (e.g., outlier cells which are not assigned to any metacell), then you need to deal with them by either masking them from the results, or providing an explicit value for them. See 
<a href="queries.html#DataAxesFormats.Queries.IfNot">
<code>IfNot
</code>
</a> for details. The example below just masks such cells out.
</p>
<pre>
<code class="language-julia hljs">metacells = example_metacells_daf()
# Axis(&quot;cell&quot;) |&gt; Lookup(&quot;metacell&quot;) |&gt; IfNot() |&gt; Fetch(&quot;type&quot;) |&gt; Fetch(&quot;color&quot;) |&gt; get_query(metacells)
metacells[&quot;/ cell : metacell ?? =&gt; type =&gt; color&quot;]

# output

852-element Named SparseArrays.ReadOnly{String, 1, Vector{String}}
cell                                │
────────────────────────────────────┼────────────
demux_07_12_20_1_AACAAGATCCATTTCA-1 │   &quot;#eebb6e&quot;
demux_07_12_20_1_AAGACAAAGTTCCGTA-1 │   &quot;#eebb6e&quot;
demux_07_12_20_1_AGACTCATCTATTGTC-1 │      &quot;gold&quot;
demux_07_12_20_1_AGATAGACATTCCTCG-1 │   &quot;#eebb6e&quot;
demux_07_12_20_1_CACAGGCGTCCTACAA-1 │   &quot;#eebb6e&quot;
demux_07_12_20_1_CCTACGTAGCCAACCC-1 │   &quot;#eebb6e&quot;
demux_07_12_20_1_CTTTCAAGTGAGGAAA-1 │ &quot;steelblue&quot;
demux_07_12_20_1_GAAGGGTGTCCCTGAG-1 │   &quot;#eebb6e&quot;
⋮                                               ⋮
demux_11_04_21_2_GGCTTGGTCGTTCCTG-1 │   &quot;#eebb6e&quot;
demux_11_04_21_2_GGGACTCTCTCATGGA-1 │      &quot;gold&quot;
demux_11_04_21_2_GGGTCACCACCACATA-1 │      &quot;gold&quot;
demux_11_04_21_2_TACAACGGTTACACAC-1 │      &quot;plum&quot;
demux_11_04_21_2_TAGAGTCAGAACGCGT-1 │   &quot;#eebb6e&quot;
demux_11_04_21_2_TGCCGAGAGTCGCGAA-1 │      &quot;gold&quot;
demux_11_04_21_2_TGCTGAAAGCCGCACT-1 │      &quot;gold&quot;
demux_11_04_21_2_TTTAGTCGTCTAGTGT-1 │   &quot;#eebb6e&quot;
</code>
</pre>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.GroupBy">
<a class="docstring-binding" href="#DataAxesFormats.Queries.GroupBy">
<code>DataAxesFormats.Queries.GroupBy
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">GroupBy(property::AbstractString) &lt;: QueryOperation
</code>
</pre>
<p>A query operation that uses a (following) 
<a href="registry.html#DataAxesFormats.Registry.ReductionOperation">
<code>ReductionOperation
</code>
</a> to aggregate the values of each group of values. Will fetch the specified 
<code>property_name
</code> (possibly followed by additional 
<a href="queries.html#DataAxesFormats.Queries.Fetch">
<code>Fetch
</code>
</a> operations) and use the resulting vector for the name of the group of each value.
</p>
<p>If applied to a vector, the result is a vector with one entry per group (e.g., 
<code>/ cell : age @ type %&gt; Mean
</code> will generate a vector with an entry per cell type and whose values are the mean age of the cells of each type). If applied to a matrix, the result is a matrix with one row per group (e.g., 
<code>/ cell / gene : UMIs @ type %&gt; Max
</code> will generate a matrix with one row per type and one column per gene, whose values are the maximal UMIs count of the gene in the cells of each type).
</p>
<p>By default, the result uses only group values we actually observe, in sorted order. However, if the operation is followed by an 
<a href="queries.html#DataAxesFormats.Queries.AsAxis">
<code>AsAxis
</code>
</a> suffix, then the fetched property must correspond to an existing axis (similar to when using 
<a href="queries.html#DataAxesFormats.Queries.Fetch">
<code>Fetch
</code>
</a>), and the result will use the entries of the axis, even if we do not observe them in the data (and will ignore vector entries with an empty value). In this case, the reduction operation will fail if there are no values for some group, unless it is followed by an 
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>IfMissing
</code>
</a> suffix (e.g., 
<code>/ cell : age @ type ! %&gt; Mean
</code> will generate a vector whose entries are all the entries of the 
<code>type
</code> axis, and will ignore cells with an empty type; this will fail if there are types which are not associated with any cell. In contrast, 
<code>/ cell : age @ type ! %&gt; Mean || 0
</code> will succeed, assigning a value of zero for types which have no cells associated with them).
</p>
<pre>
<code class="language-julia hljs">chain = example_chain_daf()

# Axis(&quot;cell&quot;) |&gt; Lookup(&quot;donor&quot;) |&gt; Fetch(&quot;age&quot;) |&gt; GroupBy(&quot;metacell&quot;) |&gt; IfNot() |&gt; Fetch(&quot;type&quot;) |&gt; Mean() |&gt; get_query(chain)
chain[&quot;/ cell : donor =&gt; age @ metacell ?? =&gt; type %&gt; Mean&quot;]

# output

4-element Named SparseArrays.ReadOnly{Float32, 1, Vector{Float32}}
type     │
─────────┼────────
MEBEMP-E │ 63.9767
MEBEMP-L │ 63.9524
MPP      │  64.238
memory-B │ 62.3077
</code>
</pre>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.IfMissing">
<a class="docstring-binding" href="#DataAxesFormats.Queries.IfMissing">
<code>DataAxesFormats.Queries.IfMissing
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">IfMissing(value::StorageScalar; type::Maybe{Type} = nothing) &lt;: QueryOperation
</code>
</pre>
<p>A query operation providing a value to use if the data is missing some property. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is specified using the 
<code>||
</code> operator, followed by the value to use, and optionally followed by the data type of the value (e.g., 
<code>: score || 1 Float32
</code>).
</p>
<p>If the data type is not specified, and the 
<code>value
</code> isa 
<code>AbstractString
</code>, then the data type is deduced using 
<a href="queries.html#DataAxesFormats.Queries.guess_typed_value">
<code>guess_typed_value
</code>
</a> of the 
<code>value
</code>.
</p>
<pre>
<code class="language-julia hljs">cells = example_cells_daf()
println(Lookup(&quot;version&quot;) |&gt; IfMissing(1) |&gt; get_query(cells))
println(Lookup(&quot;version&quot;) |&gt; IfMissing(Float32(1)) |&gt; get_query(cells))
println(cells[&quot;: version || 1&quot;])
println(cells[&quot;: version || 1 Float32&quot;])

# output

1
1.0
1
1.0
</code>
</pre>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.IfNot">
<a class="docstring-binding" href="#DataAxesFormats.Queries.IfNot">
<code>DataAxesFormats.Queries.IfNot
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">IfNot(value::Maybe{StorageScalar} = nothing) &lt;: QueryOperation
</code>
</pre>
<p>A query operation providing a value to use for &quot;false-ish&quot; values in a vector (empty strings, zero numeric values, or false Boolean values). In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is indicated using the 
<code>??
</code> operator, optionally followed by a value to use.
</p>
<p>If the value is 
<code>nothing
</code> (the default), then these entries are dropped (masked out) of the result (e.g., 
<code>/ cell : type ??
</code> behaves the same as 
<code>/ cell &amp; type : type
</code>, that is, returns the type of the cells which have a non-empty type). Otherwise, this value is used instead of the &quot;false-ish&quot; value (e.g., 
<code>/ cell : type ?? Outlier
</code> will return a vector of the type of each cell, with the value 
<code>Outlier
</code> for cells with an empty type). When fetching properties, this is the final value (e.g., 
<code>/ cell : type ?? red =&gt; color
</code> will return a vector of the color of the type of each cell, with a 
<code>red
</code> color for the cells with an empty type).
</p>
<p>If the 
<code>value
</code> isa 
<code>AbstractString
</code>, then it is automatically converted to the data type of the elements of the results vector.
</p>
<pre>
<code class="language-julia hljs">metacells = example_metacells_daf()
# Axis(&quot;cell&quot;) |&gt; Lookup(&quot;metacell&quot;) |&gt; IfNot(&quot;magenta&quot;) |&gt; Fetch(&quot;type&quot;) |&gt; Fetch(&quot;color&quot;) |&gt; get_query(metacells)
metacells[&quot;/ cell : metacell ?? magenta =&gt; type =&gt; color&quot;]

# output

856-element Named SparseArrays.ReadOnly{String, 1, Vector{String}}
cell                                │
────────────────────────────────────┼──────────
demux_07_12_20_1_AACAAGATCCATTTCA-1 │ &quot;#eebb6e&quot;
demux_07_12_20_1_AACGAAAGTCCAATCA-1 │ &quot;magenta&quot;
demux_07_12_20_1_AAGACAAAGTTCCGTA-1 │ &quot;#eebb6e&quot;
demux_07_12_20_1_AGACTCATCTATTGTC-1 │    &quot;gold&quot;
demux_07_12_20_1_AGATAGACATTCCTCG-1 │ &quot;#eebb6e&quot;
demux_07_12_20_1_ATCGTAGTCCAGTGCG-1 │ &quot;magenta&quot;
demux_07_12_20_1_CACAGGCGTCCTACAA-1 │ &quot;#eebb6e&quot;
demux_07_12_20_1_CCTACGTAGCCAACCC-1 │ &quot;#eebb6e&quot;
⋮                                             ⋮
demux_11_04_21_2_GGGTCACCACCACATA-1 │    &quot;gold&quot;
demux_11_04_21_2_TACAACGGTTACACAC-1 │    &quot;plum&quot;
demux_11_04_21_2_TAGAGTCAGAACGCGT-1 │ &quot;#eebb6e&quot;
demux_11_04_21_2_TGATGCAAGGCCTGCT-1 │ &quot;magenta&quot;
demux_11_04_21_2_TGCCGAGAGTCGCGAA-1 │    &quot;gold&quot;
demux_11_04_21_2_TGCTGAAAGCCGCACT-1 │    &quot;gold&quot;
demux_11_04_21_2_TTCAGGACAGGAATAT-1 │ &quot;magenta&quot;
demux_11_04_21_2_TTTAGTCGTCTAGTGT-1 │ &quot;#eebb6e&quot;
</code>
</pre>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.Lookup">
<a class="docstring-binding" href="#DataAxesFormats.Queries.Lookup">
<code>DataAxesFormats.Queries.Lookup
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">Lookup(property::AbstractString) &lt;: Query
</code>
</pre>
<p>A query operation for looking up the value of a property with some name. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is specified using the 
<code>:
</code> operator, followed by the property name to look up.
</p>
<ul>
<li>If the query state is empty, this looks up the value of a scalar property (e.g., 
<code>: version
</code>).
</li>
<li>If the query state contains a single axis, this looks up the value of a vector property (e.g., 
<code>/ cell : batch
</code>).
</li>
<li>If the query state contains two axes, this looks up the value of a matrix property (e.g., 
<code>/ cell / gene : UMIs
</code>).
</li>
</ul>
<p>If the property does not exist, this is an error, unless this is followed by 
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>IfMissing
</code>
</a> (e.g., 
<code>: version || 1.0
</code>).
</p>
<p>If any of the axes has a single entry selected using 
<a href="queries.html#DataAxesFormats.Queries.IsEqual">
<code>IsEqual
</code>
</a>, this will reduce the dimension of the result (e.g., 
<code>/ cell / gene = FOXP1 : UMIs
</code> is a vector, and both 
<code>/ cell = C1 / gene = FOXP1 : UMIs
</code> and 
<code>/ gene = FOXP1 : is_marker
</code> are scalars).
</p>
<div class="admonition is-info" id="Note-1bbfd95679f9b7c8">
<header class="admonition-header">Note
<a class="admonition-anchor" href="#Note-1bbfd95679f9b7c8" title="Permalink">
</a>
</header>
<div class="admonition-body">
<p>This, 
<a href="queries.html#DataAxesFormats.Queries.Names">
<code>Names
</code>
</a> and 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a> are the only 
<a href="registry.html#DataAxesFormats.Registry.QueryOperation">
<code>QueryOperation
</code>
</a>s that also works as a complete 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>.
</p>
</div>
</div>
<pre>
<code class="language-julia hljs">cells = example_cells_daf()
println(Lookup(&quot;organism&quot;) |&gt; get_query(cells))
println(cells[&quot;: organism&quot;])

# output

human
human
</code>
</pre>
<pre>
<code class="language-julia hljs">metacells = example_metacells_daf()
println(String.(Axis(&quot;type&quot;) |&gt; Lookup(&quot;color&quot;) |&gt; get_query(metacells)))
println(String.(metacells[&quot;/ type : color&quot;]))

# output

[&quot;#eebb6e&quot;, &quot;plum&quot;, &quot;gold&quot;, &quot;steelblue&quot;]
[&quot;#eebb6e&quot;, &quot;plum&quot;, &quot;gold&quot;, &quot;steelblue&quot;]
</code>
</pre>
<pre>
<code class="language-julia hljs">metacells = example_metacells_daf()
# Axis(&quot;metacell&quot;) |&gt; Axis(&quot;gene&quot;) |&gt; Lookup(&quot;fraction&quot;) |&gt; get_query(metacells)
metacells[&quot;/ metacell / gene : fraction&quot;]

# output

7×683 Named SparseArrays.ReadOnly{Float32, 2, Matrix{Float32}}
metacell ╲ gene │        RPL22         PARK7  …          TTC3         HMGN1
────────────────┼──────────────────────────────────────────────────────────
M1671.28        │   0.00447666    8.52301f-5  …   0.000111978   0.000345676
M2357.20        │    0.0041286   0.000154199       0.00011131   0.000287754
M2169.56        │   0.00474096   0.000110458      0.000108683   0.000415481
M2576.86        │   0.00441595   0.000122259      0.000144736   0.000317384
M1440.15        │   0.00455642   0.000116962       8.57345f-5   0.000320543
M756.63         │   0.00434327   0.000108019      0.000100166   0.000264526
M412.08         │   0.00373581    6.50531f-5  …   0.000122469   0.000160654
</code>
</pre>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.Names">
<a class="docstring-binding" href="#DataAxesFormats.Queries.Names">
<code>DataAxesFormats.Queries.Names
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">Names(kind::Maybe{AbstractString} = nothing) &lt;: Query
</code>
</pre>
<p>A query operation for looking up a set of names. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is specified using the 
<code>?
</code> operator, optionally followed by the kind of objects to name.
</p>
<ul>
<li>If the query state is empty, a 
<code>kind
</code> must be specified, one of 
<code>scalars
</code> or 
<code>axes
</code>, and the result is the set of their names (
<code>? scalars
</code>, 
<code>? axes
</code>).
</li>
<li>If the query state contains a single axis (without any masks), the 
<code>kind
</code> must not be specified, and the result is the set of names of vector properties of the axis (e.g., 
<code>/ cell ?
</code>).
</li>
<li>If the query state contains two axes (without any masks), the 
<code>kind
</code> must not be specified, and the result is the set of names of matrix properties of the axes (e.g., 
<code>/ cell / gene ?
</code>).
</li>
</ul>
<div class="admonition is-info" id="Note-d54e179ec5e0fd25">
<header class="admonition-header">Note
<a class="admonition-anchor" href="#Note-d54e179ec5e0fd25" title="Permalink">
</a>
</header>
<div class="admonition-body">
<p>This, 
<a href="queries.html#DataAxesFormats.Queries.Lookup">
<code>Lookup
</code>
</a> and 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a> are the only 
<a href="registry.html#DataAxesFormats.Registry.QueryOperation">
<code>QueryOperation
</code>
</a>s that also works as a complete 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>.
</p>
</div>
</div>
<pre>
<code class="language-julia hljs">cells = example_cells_daf()
println(Names(&quot;scalars&quot;) |&gt; get_query(cells))
println(sort!(String.(cells[&quot;? axes&quot;])))

# output

AbstractString[&quot;organism&quot;]
[&quot;cell&quot;, &quot;donor&quot;, &quot;experiment&quot;, &quot;gene&quot;]
</code>
</pre>
<pre>
<code class="language-julia hljs">cells = example_cells_daf()
println(sort!(String.(Axis(&quot;cell&quot;) |&gt; Names() |&gt; get_query(cells))))
println(sort!(String.(cells[&quot;/ cell ?&quot;])))

# output

[&quot;donor&quot;, &quot;experiment&quot;]
[&quot;donor&quot;, &quot;experiment&quot;]
</code>
</pre>
<pre>
<code class="language-julia hljs">cells = example_cells_daf()
println(Axis(&quot;cell&quot;) |&gt; Axis(&quot;gene&quot;) |&gt; Names() |&gt; get_query(cells))
println(cells[&quot;/ cell / gene ?&quot;])

# output

Set(AbstractString[&quot;UMIs&quot;])
Set(AbstractString[&quot;UMIs&quot;])
</code>
</pre>
<div class="admonition is-info" id="Note-9034585fd7d17cdc">
<header class="admonition-header">Note
<a class="admonition-anchor" href="#Note-9034585fd7d17cdc" title="Permalink">
</a>
</header>
<div class="admonition-body">
<p>The results are always a set of strings, never a vector. We sort them to force reproducible results across Julia versions. Even when we don&#39;t (in single-result cases), sometimes 
<code>println
</code> shows them as a vector, because &quot;reasons&quot;.
</p>
</div>
</div>
</div>
</section>
</details>
</article>
<h3 id="Mask-Operators">
<a class="docs-heading-anchor" href="#Mask-Operators">Mask Operators
</a>
<a id="Mask-Operators-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Mask-Operators" title="Permalink">
</a>
</h3>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.And">
<a class="docstring-binding" href="#DataAxesFormats.Queries.And">
<code>DataAxesFormats.Queries.And
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">And(property::AbstractString) &lt;: QueryOperation
</code>
</pre>
<p>A query operation for restricting the set of entries of an 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a>. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is specified using the 
<code>&amp;
</code> operator, followed by the name of an axis property to look up to compute the mask.
</p>
<p>The mask may be just the fetched property (e.g., 
<code>/ gene &amp; is_marker
</code> will restrict the result vector to only marker genes). If the value of the property is not Boolean, it is automatically compared to 
<code>0
</code> or the empty string, depending on its type (e.g., 
<code>/ cell &amp; type
</code> will restrict the result vector to only cells which were given a non-empty-string type annotation). It is also possible to fetch properties from other axes, and use an explicit 
<a href="queries.html#DataAxesFormats.Queries.ComparisonOperation">
<code>ComparisonOperation
</code>
</a> to compute the Boolean mask (e.g., 
<code>/ cell &amp; batch =&gt; age &gt; 1
</code> will restrict the result vector to cells whose batch has an age larger than 1).
</p>
<pre>
<code class="language-julia hljs">chain = example_chain_daf()
# Axis(&quot;cell&quot;) |&gt; And(&quot;donor&quot;) |&gt; IsEqual(&quot;N16&quot;) |&gt; get_query(chain)
chain[&quot;/ cell &amp; donor = N16&quot;]

# output

10-element SparseArrays.ReadOnly{SubString{StringViews.StringView{Vector{UInt8}}}, 1, Vector{SubString{StringViews.StringView{Vector{UInt8}}}}}:
 &quot;demux_21_01_21_1_AACCCAATCGAGAATA-1&quot;
 &quot;demux_21_01_21_1_CACAGGCTCTTAGCCC-1&quot;
 &quot;demux_21_01_21_1_CTACGGGTCGTGCGAC-1&quot;
 &quot;demux_21_01_21_1_GAGATGGAGGGATCAC-1&quot;
 &quot;demux_21_01_21_1_GCCAGGTAGCGGTAGT-1&quot;
 &quot;demux_21_01_21_1_GCGTGCATCCGGCAGT-1&quot;
 &quot;demux_21_01_21_1_TCAATTCAGCTTCTAG-1&quot;
 &quot;demux_21_01_21_1_TCGCTTGGTCTTGTCC-1&quot;
 &quot;demux_21_01_21_1_TCTTTGAAGCGGGTAT-1&quot;
 &quot;demux_21_01_21_1_TTCTCTCCAACGGCCT-1&quot;
</code>
</pre>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.AndNot">
<a class="docstring-binding" href="#DataAxesFormats.Queries.AndNot">
<code>DataAxesFormats.Queries.AndNot
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">AndNot(property::AbstractString) &lt;: QueryOperation
</code>
</pre>
<p>Same as 
<a href="queries.html#DataAxesFormats.Queries.And">
<code>And
</code>
</a> but use the inverse of the mask. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is specified using the 
<code>&amp;!
</code> operator, followed by the name of an axis property to look up to compute the mask.
</p>
<pre>
<code class="language-julia hljs">chain = example_chain_daf()
# Axis(&quot;cell&quot;) |&gt; AndNot(&quot;donor&quot;) &amp;&gt; IsEqual(&quot;N16&quot;) |&gt; get_query(chain)
chain[&quot;/ cell &amp;! donor = N16&quot;]

# output

846-element SparseArrays.ReadOnly{SubString{StringViews.StringView{Vector{UInt8}}}, 1, Vector{SubString{StringViews.StringView{Vector{UInt8}}}}}:
 &quot;demux_07_12_20_1_AACAAGATCCATTTCA-1&quot;
 &quot;demux_07_12_20_1_AACGAAAGTCCAATCA-1&quot;
 &quot;demux_07_12_20_1_AAGACAAAGTTCCGTA-1&quot;
 &quot;demux_07_12_20_1_AGACTCATCTATTGTC-1&quot;
 &quot;demux_07_12_20_1_AGATAGACATTCCTCG-1&quot;
 &quot;demux_07_12_20_1_ATCGTAGTCCAGTGCG-1&quot;
 &quot;demux_07_12_20_1_CACAGGCGTCCTACAA-1&quot;
 &quot;demux_07_12_20_1_CCTACGTAGCCAACCC-1&quot;
 &quot;demux_07_12_20_1_CTTTCAAGTGAGGAAA-1&quot;
 &quot;demux_07_12_20_1_GAAGGGTGTCCCTGAG-1&quot;
 ⋮
 &quot;demux_11_04_21_2_GGGACTCTCTCATGGA-1&quot;
 &quot;demux_11_04_21_2_GGGTCACCACCACATA-1&quot;
 &quot;demux_11_04_21_2_TACAACGGTTACACAC-1&quot;
 &quot;demux_11_04_21_2_TAGAGTCAGAACGCGT-1&quot;
 &quot;demux_11_04_21_2_TGATGCAAGGCCTGCT-1&quot;
 &quot;demux_11_04_21_2_TGCCGAGAGTCGCGAA-1&quot;
 &quot;demux_11_04_21_2_TGCTGAAAGCCGCACT-1&quot;
 &quot;demux_11_04_21_2_TTCAGGACAGGAATAT-1&quot;
 &quot;demux_11_04_21_2_TTTAGTCGTCTAGTGT-1&quot;
</code>
</pre>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.Or">
<a class="docstring-binding" href="#DataAxesFormats.Queries.Or">
<code>DataAxesFormats.Queries.Or
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">Or(property::AbstractString) &lt;: QueryOperation
</code>
</pre>
<p>A query operation for expanding the set of entries of an 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a>. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is specified using the 
<code>|
</code> operator, followed by the name of an axis property to look up to compute the mask.
</p>
<p>This works similarly to 
<a href="queries.html#DataAxesFormats.Queries.And">
<code>And
</code>
</a>, except that it adds to the mask (e.g., 
<code>/ gene &amp; is_marker | is_noisy
</code> will restrict the result vector to either marker or noisy genes).
</p>
<pre>
<code class="language-julia hljs">chain = example_chain_daf()
# Axis(&quot;cell&quot;) |&gt; And(&quot;donor&quot;) |&gt; IsEqual(&quot;N16&quot;) |&gt; Or(&quot;donor&quot;) |&gt; IsEqual(&quot;N15&quot;) |&gt; get_query(chain)
chain[&quot;/ cell &amp; donor = N16 | donor = N17&quot;]

# output

20-element SparseArrays.ReadOnly{SubString{StringViews.StringView{Vector{UInt8}}}, 1, Vector{SubString{StringViews.StringView{Vector{UInt8}}}}}:
 &quot;demux_21_01_21_1_AACCCAATCGAGAATA-1&quot;
 &quot;demux_21_01_21_1_AACGTCACATCCGAGC-1&quot;
 &quot;demux_21_01_21_1_ACCCAAAAGGTCCCGT-1&quot;
 &quot;demux_21_01_21_1_ACTTTCAAGTCCCAGC-1&quot;
 &quot;demux_21_01_21_1_AGATCGTGTACTCCGG-1&quot;
 &quot;demux_21_01_21_1_AGTAGCTGTATCAGGG-1&quot;
 &quot;demux_21_01_21_1_CACAGGCTCTTAGCCC-1&quot;
 &quot;demux_21_01_21_1_CTACGGGTCGTGCGAC-1&quot;
 &quot;demux_21_01_21_1_CTGCCTACACGCAGTC-1&quot;
 &quot;demux_21_01_21_1_GAGATGGAGGGATCAC-1&quot;
 &quot;demux_21_01_21_1_GATCAGTAGTCGAAAT-1&quot;
 &quot;demux_21_01_21_1_GCCAGGTAGCGGTAGT-1&quot;
 &quot;demux_21_01_21_1_GCGTGCATCCGGCAGT-1&quot;
 &quot;demux_21_01_21_1_GTTCTATGTATCCCTC-1&quot;
 &quot;demux_21_01_21_1_TCAATTCAGCTTCTAG-1&quot;
 &quot;demux_21_01_21_1_TCGCTTGGTCTTGTCC-1&quot;
 &quot;demux_21_01_21_1_TCTTTGAAGCGGGTAT-1&quot;
 &quot;demux_21_01_21_1_TGTAACGCATGGCCAC-1&quot;
 &quot;demux_21_01_21_1_TGTACAGGTTTGAACC-1&quot;
 &quot;demux_21_01_21_1_TTCTCTCCAACGGCCT-1&quot;
</code>
</pre>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.OrNot">
<a class="docstring-binding" href="#DataAxesFormats.Queries.OrNot">
<code>DataAxesFormats.Queries.OrNot
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">OrNot(property::AbstractString) &lt;: QueryOperation
</code>
</pre>
<p>Same as 
<a href="queries.html#DataAxesFormats.Queries.Or">
<code>Or
</code>
</a> but use the inverse of the mask. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is specified using the 
<code>|!
</code> operator, followed by the name of an axis property to look up to compute the mask.
</p>
<pre>
<code class="language-julia hljs">chain = example_chain_daf()
# Axis(&quot;cell&quot;) |&gt; And(&quot;donor&quot;) |&gt; IsEqual(&quot;N16&quot;) |&gt; OrNot(&quot;metacell&quot;) |&gt; get_query(chain)
chain[&quot;/ cell &amp; donor = N16 |! metacell&quot;]

# output

14-element SparseArrays.ReadOnly{SubString{StringViews.StringView{Vector{UInt8}}}, 1, Vector{SubString{StringViews.StringView{Vector{UInt8}}}}}:
 &quot;demux_07_12_20_1_AACGAAAGTCCAATCA-1&quot;
 &quot;demux_07_12_20_1_ATCGTAGTCCAGTGCG-1&quot;
 &quot;demux_21_01_21_1_AACCCAATCGAGAATA-1&quot;
 &quot;demux_21_01_21_1_CACAGGCTCTTAGCCC-1&quot;
 &quot;demux_21_01_21_1_CTACGGGTCGTGCGAC-1&quot;
 &quot;demux_21_01_21_1_GAGATGGAGGGATCAC-1&quot;
 &quot;demux_21_01_21_1_GCCAGGTAGCGGTAGT-1&quot;
 &quot;demux_21_01_21_1_GCGTGCATCCGGCAGT-1&quot;
 &quot;demux_21_01_21_1_TCAATTCAGCTTCTAG-1&quot;
 &quot;demux_21_01_21_1_TCGCTTGGTCTTGTCC-1&quot;
 &quot;demux_21_01_21_1_TCTTTGAAGCGGGTAT-1&quot;
 &quot;demux_21_01_21_1_TTCTCTCCAACGGCCT-1&quot;
 &quot;demux_11_04_21_2_TGATGCAAGGCCTGCT-1&quot;
 &quot;demux_11_04_21_2_TTCAGGACAGGAATAT-1&quot;
</code>
</pre>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.Xor">
<a class="docstring-binding" href="#DataAxesFormats.Queries.Xor">
<code>DataAxesFormats.Queries.Xor
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">Xor(property::AbstractString) &lt;: QueryOperation
</code>
</pre>
<p>A query operation for flipping the set of entries of an 
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>Axis
</code>
</a>. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is specified using the 
<code>^
</code> operator, followed by the name of an axis property to look up to compute the mask.
</p>
<p>This works similarly to 
<a href="queries.html#DataAxesFormats.Queries.Or">
<code>Or
</code>
</a>, except that it flips entries in the mask (e.g., 
<code>/ gene &amp; is_marker ^ is_noisy
</code> will restrict the result vector to either marker or noisy genes, but not both).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.XorNot">
<a class="docstring-binding" href="#DataAxesFormats.Queries.XorNot">
<code>DataAxesFormats.Queries.XorNot
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">XorNot(property::AbstractString) &lt;: QueryOperation
</code>
</pre>
<p>Same as 
<a href="queries.html#DataAxesFormats.Queries.Xor">
<code>Xor
</code>
</a> but use the inverse of the mask. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is specified using the 
<code>^!
</code> operator, followed by the name of an axis property to look up to compute the mask.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.MaskSlice">
<a class="docstring-binding" href="#DataAxesFormats.Queries.MaskSlice">
<code>DataAxesFormats.Queries.MaskSlice
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">MaskSlice(axis_name::AbstractString) &lt;: QueryOperation
</code>
</pre>
<p>A query operation for using a slice of a matrix as a mask, when the other axis of the matrix is different from the mask axis. This needs to be followed by the axis entry to slice. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is specified using the 
<code>;
</code> operator, followed by the name of the axis for looking up the matrix, then followed by 
<code>=
</code> and the value identifying the slice.
</p>
<p>That is, suppose we have a UMIs matrix per cell per gene, and we&#39;d like to select all the cells which have non-zero UMIs for the FOXP1 gene. Then we can say 
<code>/ cell &amp; UMIs ; gene = FOXP1 &gt; 0
</code> (or just 
<code>/ cell &amp; UMIs ; gene = FOXP1
</code> since the 
<code>&gt; 0
</code> is implicit).
</p>
<pre>
<code class="language-julia hljs">cells = example_cells_daf()
# Axis(&quot;cell&quot;) |&gt; And(&quot;UMIs&quot;) |&gt; MaskSlice(&quot;gene&quot;) |&gt; IsEqual(&quot;FOXP1&quot;) |&gt; get_query(cells)
cells[&quot;/ cell &amp; UMIs ; gene = FOXP1&quot;]

# output

372-element SparseArrays.ReadOnly{SubString{StringViews.StringView{Vector{UInt8}}}, 1, Vector{SubString{StringViews.StringView{Vector{UInt8}}}}}:
 &quot;demux_07_12_20_1_AACAAGATCCATTTCA-1&quot;
 &quot;demux_07_12_20_1_AACGAAAGTCCAATCA-1&quot;
 &quot;demux_07_12_20_1_AGACTCATCTATTGTC-1&quot;
 &quot;demux_07_12_20_1_ATCGTAGTCCAGTGCG-1&quot;
 &quot;demux_07_12_20_1_CACAGGCGTCCTACAA-1&quot;
 &quot;demux_07_12_20_1_CTTTCAAGTGAGGAAA-1&quot;
 &quot;demux_07_12_20_1_GAAGGGTGTCCCTGAG-1&quot;
 &quot;demux_07_12_20_1_GCAGCCAGTGTTACAC-1&quot;
 &quot;demux_07_12_20_1_GTTAGACGTCGGCACT-1&quot;
 &quot;demux_07_12_20_1_TCCTTCTTCTACTGAG-1&quot;
 ⋮
 &quot;demux_11_04_21_2_ATGGGAGTCCTGTTAT-1&quot;
 &quot;demux_11_04_21_2_CATGGTATCGTTAGAC-1&quot;
 &quot;demux_11_04_21_2_CCTACGTCAGACCAGA-1&quot;
 &quot;demux_11_04_21_2_CGTGAATGTGAGTGAC-1&quot;
 &quot;demux_11_04_21_2_GGCTTGGTCGTTCCTG-1&quot;
 &quot;demux_11_04_21_2_GGGTCACCACCACATA-1&quot;
 &quot;demux_11_04_21_2_TACAACGGTTACACAC-1&quot;
 &quot;demux_11_04_21_2_TGCTGAAAGCCGCACT-1&quot;
 &quot;demux_11_04_21_2_TTTAGTCGTCTAGTGT-1&quot;
</code>
</pre>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.SquareMaskColumn">
<a class="docstring-binding" href="#DataAxesFormats.Queries.SquareMaskColumn">
<code>DataAxesFormats.Queries.SquareMaskColumn
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">SquareMaskColumn(comparison_value::AbstractString) &lt;: QueryOperation
</code>
</pre>
<p>Similar to 
<a href="queries.html#DataAxesFormats.Queries.MaskSlice">
<code>MaskSlice
</code>
</a> but is used when the mask matrix is square and we&#39;d like to use a column as a mask. This therefore only needs specifying the column to slice. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is specified using the 
<code>;=
</code> operator followed by the value identifying the slice.
</p>
<p>That is, suppose we have a KNN graph between metacells as a metacell-metacell matrix where each column contains the weights of the outgoing edges from each metacell to the rest. To select all the metacells reachable from a particular one, we can say 
<code>/ metacell &amp; edge_weight ;= M2169.56 &gt; 0
</code> (or just 
<code>/ metacell &amp; edge_weight ;= M2169.56
</code> as the 
<code>&gt; 0
</code> is implicit). If we also want to include the source cell we&#39;d need to say 
<code>/ metacell &amp; name = M2169.56 | edge_weight ;= M2169.56
</code>, etc.
</p>
<pre>
<code class="language-julia hljs">metacells = example_metacells_daf()
println(String.(Axis(&quot;metacell&quot;) |&gt; And(&quot;edge_weight&quot;) |&gt; SquareMaskColumn(&quot;M2169.56&quot;) |&gt; get_query(metacells)))
println(String.(metacells[&quot;/ metacell &amp; edge_weight ;= M2169.56&quot;]))

# output

[&quot;M2357.20&quot;, &quot;M756.63&quot;, &quot;M412.08&quot;]
[&quot;M2357.20&quot;, &quot;M756.63&quot;, &quot;M412.08&quot;]
</code>
</pre>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.SquareMaskRow">
<a class="docstring-binding" href="#DataAxesFormats.Queries.SquareMaskRow">
<code>DataAxesFormats.Queries.SquareMaskRow
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">SquareMaskRow(comparison_value::AbstractString) &lt;: QueryOperation
</code>
</pre>
<p>Similar to 
<a href="queries.html#DataAxesFormats.Queries.SquareMaskRow">
<code>SquareMaskRow
</code>
</a> but is used when the mask matrix is square and we&#39;d like to use a row as a mask. This therefore only needs specifying the row to slice. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is specified using the 
<code>,=
</code> operator followed by the value identifying the slice.
</p>
<p>That is, suppose we have a KNN graph as above and we&#39;d like to select all cells that can reach a particular one. Then 
<code>/ metacell &amp; edge_weight ,= M2169.56 &gt; 0
</code> (or just 
<code>/ metacell &amp; edge_weight ,= M2169.56
</code> as the 
<code>&gt; 0
</code> is implicit). If we also want to include the source cell we&#39;d need to say 
<code>/ metacell &amp; name = M2169.56 | edge_weight ,= M2169.56
</code>, etc.
</p>
<pre>
<code class="language-julia hljs">metacells = example_metacells_daf()
println(String.(Axis(&quot;metacell&quot;) |&gt; And(&quot;edge_weight&quot;) |&gt; SquareMaskRow(&quot;M2169.56&quot;) |&gt; get_query(metacells)))
println(String.(metacells[&quot;/ metacell &amp; edge_weight ,= M2169.56&quot;]))

# output

[&quot;M1671.28&quot;, &quot;M1440.15&quot;]
[&quot;M1671.28&quot;, &quot;M1440.15&quot;]
</code>
</pre>
</div>
</section>
</details>
</article>
<h3 id="Comparison-Operators">
<a class="docs-heading-anchor" href="#Comparison-Operators">Comparison Operators
</a>
<a id="Comparison-Operators-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Comparison-Operators" title="Permalink">
</a>
</h3>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.ComparisonOperation">
<a class="docstring-binding" href="#DataAxesFormats.Queries.ComparisonOperation">
<code>DataAxesFormats.Queries.ComparisonOperation
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<p>
<code>ComparisonOperation
</code> := ( 
<a href="queries.html#DataAxesFormats.Queries.IsLess">
<code>IsLess
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.IsLessEqual">
<code>IsLessEqual
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.IsEqual">
<code>IsEqual
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.IsNotEqual">
<code>IsNotEqual
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.IsGreater">
<code>IsGreater
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.IsGreaterEqual">
<code>IsGreaterEqual
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.IsMatch">
<code>IsMatch
</code>
</a> | 
<a href="queries.html#DataAxesFormats.Queries.IsNotMatch">
<code>IsNotMatch
</code>
</a> )
</p>
<p>A query operation computing a mask by comparing the values of a vector with some constant (e.g., 
<code>/ cell &amp; age &gt; 0
</code>). In addition, the 
<a href="queries.html#DataAxesFormats.Queries.IsEqual">
<code>IsEqual
</code>
</a> operation can be used to slice an entry from a vector (e.g., 
<code>/ gene = FOXP1 : is_marker
</code>) or a matrix (e.g., 
<code>/ cell / gene = FOXP1 &amp; UMIs
</code>, 
<code>/ cell = ATCG / gene = FOXP1 : UMIs
</code>).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.IsEqual">
<a class="docstring-binding" href="#DataAxesFormats.Queries.IsEqual">
<code>DataAxesFormats.Queries.IsEqual
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">IsEqual(value::StorageScalar) &lt;: QueryOperation
</code>
</pre>
<p>Equality is used for two purposes:
</p>
<ul>
<li>As a comparison operator, similar to 
<a href="queries.html#DataAxesFormats.Queries.IsLess">
<code>IsLess
</code>
</a> except that uses 
<code>=
</code> instead of 
<code>&lt;
</code> for the comparison.
</li>
<li>To select a single entry from a vector. This allows a query to select a single scalar from a vector (e.g., 
<code>/ gene = FOXP1 : is_marker
</code>) or from a matrix (e.g., 
<code>/ cell = ATCG / gene = FOXP1 : UMIs
</code>); or to slice a single vector from a matrix (e.g., 
<code>/ cell = ATCG / gene : UMIs
</code> or 
<code>/ cell / gene = FOXP1 : UMIs
</code>).
</li>
</ul>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.IsGreater">
<a class="docstring-binding" href="#DataAxesFormats.Queries.IsGreater">
<code>DataAxesFormats.Queries.IsGreater
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">IsGreater(value::StorageScalar) &lt;: QueryOperation
</code>
</pre>
<p>Similar to 
<a href="queries.html#DataAxesFormats.Queries.IsLess">
<code>IsLess
</code>
</a> except that uses 
<code>&gt;
</code> instead of 
<code>&lt;
</code> for the comparison.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.IsGreaterEqual">
<a class="docstring-binding" href="#DataAxesFormats.Queries.IsGreaterEqual">
<code>DataAxesFormats.Queries.IsGreaterEqual
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">IsGreaterEqual(value::StorageScalar) &lt;: QueryOperation
</code>
</pre>
<p>Similar to 
<a href="queries.html#DataAxesFormats.Queries.IsLess">
<code>IsLess
</code>
</a> except that uses 
<code>&gt;=
</code> instead of 
<code>&lt;
</code> for the comparison.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.IsLess">
<a class="docstring-binding" href="#DataAxesFormats.Queries.IsLess">
<code>DataAxesFormats.Queries.IsLess
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">IsLess(value::StorageScalar) &lt;: QueryOperation
</code>
</pre>
<p>A query operation for converting a vector value to a Boolean mask by comparing it some value. In a string 
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>Query
</code>
</a>, this is specified using the 
<code>&lt;
</code> operator, followed by the value to compare with.
</p>
<p>A string value is automatically converted into the same type as the vector values (e.g., 
<code>/ cell &amp; probability &lt; 0.5
</code> will restrict the result vector only to cells whose probability is less than half).
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.IsLessEqual">
<a class="docstring-binding" href="#DataAxesFormats.Queries.IsLessEqual">
<code>DataAxesFormats.Queries.IsLessEqual
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">IsLessEqual(value::StorageScalar) &lt;: QueryOperation
</code>
</pre>
<p>Similar to 
<a href="queries.html#DataAxesFormats.Queries.IsLess">
<code>IsLess
</code>
</a> except that uses 
<code>&lt;=
</code> instead of 
<code>&lt;
</code> for the comparison.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.IsMatch">
<a class="docstring-binding" href="#DataAxesFormats.Queries.IsMatch">
<code>DataAxesFormats.Queries.IsMatch
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">IsMatch(value::Union{AbstractString, Regex}) &lt;: QueryOperation
</code>
</pre>
<p>Similar to 
<a href="queries.html#DataAxesFormats.Queries.IsLess">
<code>IsLess
</code>
</a> except that the compared values must be strings, and the mask is of the values that match the given regular expression.
</p>
<div class="admonition is-info" id="Note-e6a31633267b73db">
<header class="admonition-header">Note
<a class="admonition-anchor" href="#Note-e6a31633267b73db" title="Permalink">
</a>
</header>
<div class="admonition-body">
<p>This will succeed on partial matches. You therefore typically need to add 
<code>^
</code> and/or 
<code>$
</code> to the regular expression to avoid matching in the middle of the value.
</p>
</div>
</div>
<pre>
<code class="language-julia hljs">cells = example_cells_daf()
#Axis(&quot;gene&quot;) |&gt; And(&quot;name&quot;) |&gt; IsMatch(r&quot;^RP[LS]&quot;) |&gt; get_query(cells)
cells[q&quot;/ gene &amp; name ~ \^RP\[LS\]&quot;]

# output

78-element SparseArrays.ReadOnly{SubString{StringViews.StringView{Vector{UInt8}}}, 1, Vector{SubString{StringViews.StringView{Vector{UInt8}}}}}:
 &quot;RPL22&quot;
 &quot;RPL11&quot;
 &quot;RPS8&quot;
 &quot;RPL5&quot;
 &quot;RPS27&quot;
 &quot;RPS7&quot;
 &quot;RPS27A&quot;
 &quot;RPL31&quot;
 &quot;RPL37A&quot;
 &quot;RPL32&quot;
 ⋮
 &quot;RPS19&quot;
 &quot;RPL18&quot;
 &quot;RPL13A&quot;
 &quot;RPS11&quot;
 &quot;RPS9&quot;
 &quot;RPL28&quot;
 &quot;RPS5&quot;
 &quot;RPS4Y1&quot;
 &quot;RPL3&quot;
</code>
</pre>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.IsNotEqual">
<a class="docstring-binding" href="#DataAxesFormats.Queries.IsNotEqual">
<code>DataAxesFormats.Queries.IsNotEqual
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">IsNotEqual(value::StorageScalar) &lt;: QueryOperation
</code>
</pre>
<p>Similar to 
<a href="queries.html#DataAxesFormats.Queries.IsLess">
<code>IsLess
</code>
</a> except that uses 
<code>!=
</code> instead of 
<code>&lt;
</code> for the comparison.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Queries.IsNotMatch">
<a class="docstring-binding" href="#DataAxesFormats.Queries.IsNotMatch">
<code>DataAxesFormats.Queries.IsNotMatch
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">IsNotMatch(value::Union{AbstractString, Regex}) &lt;: QueryOperation
</code>
</pre>
<p>Similar to 
<a href="queries.html#DataAxesFormats.Queries.IsMatch">
<code>IsMatch
</code>
</a> except that looks for entries that do not match the pattern.
</p>
</div>
</section>
</details>
</article>
<h2 id="Index">
<a class="docs-heading-anchor" href="#Index">Index
</a>
<a id="Index-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Index" title="Permalink">
</a>
</h2>
<ul>
<li>
<a href="queries.html#DataAxesFormats.Queries">
<code>DataAxesFormats.Queries
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.AXIS_MASK">
<code>DataAxesFormats.Queries.AXIS_MASK
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.COUNTS_MATRIX">
<code>DataAxesFormats.Queries.COUNTS_MATRIX
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.GROUP_BY">
<code>DataAxesFormats.Queries.GROUP_BY
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.LOOKUP_PROPERTY">
<code>DataAxesFormats.Queries.LOOKUP_PROPERTY
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.MASK_OPERATION">
<code>DataAxesFormats.Queries.MASK_OPERATION
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.MASK_SLICE">
<code>DataAxesFormats.Queries.MASK_SLICE
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.MATRIX_COLUMN">
<code>DataAxesFormats.Queries.MATRIX_COLUMN
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.MATRIX_ENTRY">
<code>DataAxesFormats.Queries.MATRIX_ENTRY
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.MATRIX_LOOKUP">
<code>DataAxesFormats.Queries.MATRIX_LOOKUP
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.MATRIX_QUERY">
<code>DataAxesFormats.Queries.MATRIX_QUERY
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.MATRIX_ROW">
<code>DataAxesFormats.Queries.MATRIX_ROW
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.NAMES_QUERY">
<code>DataAxesFormats.Queries.NAMES_QUERY
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.POST_PROCESS">
<code>DataAxesFormats.Queries.POST_PROCESS
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.QUERY_OPERATORS">
<code>DataAxesFormats.Queries.QUERY_OPERATORS
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.REDUCE_MATRIX">
<code>DataAxesFormats.Queries.REDUCE_MATRIX
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.REDUCE_VECTOR">
<code>DataAxesFormats.Queries.REDUCE_VECTOR
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.SCALAR_QUERY">
<code>DataAxesFormats.Queries.SCALAR_QUERY
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.VECTOR_ENTRY">
<code>DataAxesFormats.Queries.VECTOR_ENTRY
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.VECTOR_FETCH">
<code>DataAxesFormats.Queries.VECTOR_FETCH
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.VECTOR_LOOKUP">
<code>DataAxesFormats.Queries.VECTOR_LOOKUP
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.VECTOR_PROPERTY">
<code>DataAxesFormats.Queries.VECTOR_PROPERTY
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.VECTOR_QUERY">
<code>DataAxesFormats.Queries.VECTOR_QUERY
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.And">
<code>DataAxesFormats.Queries.And
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.AndNot">
<code>DataAxesFormats.Queries.AndNot
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.AsAxis">
<code>DataAxesFormats.Queries.AsAxis
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.Axis">
<code>DataAxesFormats.Queries.Axis
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.ComparisonOperation">
<code>DataAxesFormats.Queries.ComparisonOperation
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.CountBy">
<code>DataAxesFormats.Queries.CountBy
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.Fetch">
<code>DataAxesFormats.Queries.Fetch
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.FrameColumn">
<code>DataAxesFormats.Queries.FrameColumn
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.FrameColumns">
<code>DataAxesFormats.Queries.FrameColumns
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.GroupBy">
<code>DataAxesFormats.Queries.GroupBy
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.IfMissing">
<code>DataAxesFormats.Queries.IfMissing
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.IfNot">
<code>DataAxesFormats.Queries.IfNot
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.IsEqual">
<code>DataAxesFormats.Queries.IsEqual
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.IsGreater">
<code>DataAxesFormats.Queries.IsGreater
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.IsGreaterEqual">
<code>DataAxesFormats.Queries.IsGreaterEqual
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.IsLess">
<code>DataAxesFormats.Queries.IsLess
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.IsLessEqual">
<code>DataAxesFormats.Queries.IsLessEqual
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.IsMatch">
<code>DataAxesFormats.Queries.IsMatch
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.IsNotEqual">
<code>DataAxesFormats.Queries.IsNotEqual
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.IsNotMatch">
<code>DataAxesFormats.Queries.IsNotMatch
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.Lookup">
<code>DataAxesFormats.Queries.Lookup
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.MaskSlice">
<code>DataAxesFormats.Queries.MaskSlice
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.Names">
<code>DataAxesFormats.Queries.Names
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.Or">
<code>DataAxesFormats.Queries.Or
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.OrNot">
<code>DataAxesFormats.Queries.OrNot
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.Query">
<code>DataAxesFormats.Queries.Query
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.QuerySequence">
<code>DataAxesFormats.Queries.QuerySequence
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.QueryString">
<code>DataAxesFormats.Queries.QueryString
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.SquareMaskColumn">
<code>DataAxesFormats.Queries.SquareMaskColumn
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.SquareMaskRow">
<code>DataAxesFormats.Queries.SquareMaskRow
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.Xor">
<code>DataAxesFormats.Queries.Xor
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.XorNot">
<code>DataAxesFormats.Queries.XorNot
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.full_vector_query">
<code>DataAxesFormats.Queries.full_vector_query
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.get_frame">
<code>DataAxesFormats.Queries.get_frame
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.get_query">
<code>DataAxesFormats.Queries.get_query
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.guess_typed_value">
<code>DataAxesFormats.Queries.guess_typed_value
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.has_query">
<code>DataAxesFormats.Queries.has_query
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.is_axis_query">
<code>DataAxesFormats.Queries.is_axis_query
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.query_requires_relayout">
<code>DataAxesFormats.Queries.query_requires_relayout
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.query_result_dimensions">
<code>DataAxesFormats.Queries.query_result_dimensions
</code>
</a>
</li>
<li>
<a href="queries.html#DataAxesFormats.Queries.@q_str">
<code>DataAxesFormats.Queries.@q_str
</code>
</a>
</li>
</ul>
</article>
<nav class="docs-footer">
<a class="docs-footer-prevpage" href="read_only.html">« Read-only
</a>
<a class="docs-footer-nextpage" href="tokens.html">Tokens »
</a>
<div class="flexbox-break">
</div>
<p class="footer-message">Powered by 
<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl
</a> and the 
<a href="https://julialang.org/">Julia Programming Language
</a>.
</p>
</nav>
</div>
<div class="modal" id="documenter-settings">
<div class="modal-background">
</div>
<div class="modal-card">
<header class="modal-card-head">
<p class="modal-card-title">Settings
</p>
<button class="delete">
</button>
</header>
<section class="modal-card-body">
<p>
<label class="label">Theme
</label>
<div class="select">
<select id="documenter-themepicker">
<option value="auto">Automatic (OS)
</option>
<option value="documenter-light">documenter-light
</option>
<option value="documenter-dark">documenter-dark
</option>
<option value="catppuccin-latte">catppuccin-latte
</option>
<option value="catppuccin-frappe">catppuccin-frappe
</option>
<option value="catppuccin-macchiato">catppuccin-macchiato
</option>
<option value="catppuccin-mocha">catppuccin-mocha
</option>
</select>
</div>
</p>
<hr/>
<p>This document was generated with 
<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl
</a> version 1.16.1. Using Julia version 1.11.8.
</p>
</section>
<footer class="modal-card-foot">
</footer>
</div>
</div>
</div>
</body>
</html>
