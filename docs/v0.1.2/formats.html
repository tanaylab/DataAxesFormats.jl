
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Formats · DataAxesFormats.jl v0.1.2
</title>
<meta name="title" content="Formats · DataAxesFormats.jl v0.1.2"/>
<meta property="og:title" content="Formats · DataAxesFormats.jl v0.1.2"/>
<meta property="twitter:title" content="Formats · DataAxesFormats.jl v0.1.2"/>
<meta name="description" content="Documentation for DataAxesFormats.jl v0.1.2."/>
<meta property="og:description" content="Documentation for DataAxesFormats.jl v0.1.2."/>
<meta property="twitter:description" content="Documentation for DataAxesFormats.jl v0.1.2."/>
<script data-outdated-warner src="assets/warner.js">
</script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/>
<script>documenterBaseURL="."
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js">
</script>
<script src="search_index.js">
</script>
<script src="siteinfo.js">
</script>
<script src="../versions.js">
</script>
<link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/>
<link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/>
<link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/>
<link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/>
<link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/>
<link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/>
<script src="assets/themeswap.js">
</script>
</head>
<body>
<div id="documenter">
<nav class="docs-sidebar">
<a class="docs-logo" href="index.html">
<img src="assets/logo.svg" alt="DataAxesFormats.jl v0.1.2 logo"/>
</a>
<div class="docs-package-name">
<span class="docs-autofit">
<a href="index.html">DataAxesFormats.jl v0.1.2
</a>
</span>
</div>
<button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)
</button>
<ul class="docs-menu">
<li>
<a class="tocitem" href="index.html">Daf
</a>
</li>
<li>
<a class="tocitem" href="readers.html">Readers
</a>
</li>
<li>
<a class="tocitem" href="writers.html">Writers
</a>
</li>
<li>
<a class="tocitem" href="read_only.html">Read-only
</a>
</li>
<li>
<a class="tocitem" href="queries.html">Queries
</a>
</li>
<li>
<a class="tocitem" href="tokens.html">Tokens
</a>
</li>
<li>
<a class="tocitem" href="views.html">Views
</a>
</li>
<li>
<a class="tocitem" href="chains.html">Chains
</a>
</li>
<li>
<a class="tocitem" href="computations.html">Computations
</a>
</li>
<li>
<a class="tocitem" href="copies.html">Copies
</a>
</li>
<li>
<a class="tocitem" href="concat.html">Concat
</a>
</li>
<li>
<a class="tocitem" href="adapters.html">Adapters
</a>
</li>
<li>
<a class="tocitem" href="contracts.html">Contracts
</a>
</li>
<li class="is-active">
<a class="tocitem" href="formats.html">Formats
</a>
<ul class="internal">
<li>
<a class="tocitem" href="#Read-API">
<span>Read API
</span>
</a>
</li>
<li>
<a class="tocitem" href="#Write-API">
<span>Write API
</span>
</a>
</li>
<li>
<a class="tocitem" href="#Index">
<span>Index
</span>
</a>
</li>
</ul>
</li>
<li>
<a class="tocitem" href="keys.html">Keys
</a>
</li>
<li>
<a class="tocitem" href="memory_format.html">Memory Format
</a>
</li>
<li>
<a class="tocitem" href="h5df_format.html">H5DF Format
</a>
</li>
<li>
<a class="tocitem" href="files_format.html">Files Format
</a>
</li>
<li>
<a class="tocitem" href="complete.html">Complete Repositories
</a>
</li>
<li>
<a class="tocitem" href="anndata_format.html">AnnData Format
</a>
</li>
<li>
<a class="tocitem" href="reconstruction.html">Reconstruction
</a>
</li>
<li>
<a class="tocitem" href="registry.html">Operations registry
</a>
</li>
<li>
<a class="tocitem" href="operations.html">Query operations
</a>
</li>
<li>
<a class="tocitem" href="storage_types.html">Storage types
</a>
</li>
<li>
<a class="tocitem" href="groups.html">Groups
</a>
</li>
<li>
<a class="tocitem" href="example_data.html">Example data
</a>
</li>
</ul>
<div class="docs-version-selector field has-addons">
<div class="control">
<span class="docs-label button is-static is-size-7">Version
</span>
</div>
<div class="docs-selector control is-expanded">
<div class="select is-fullwidth is-size-7">
<select id="documenter-version-selector">
</select>
</div>
</div>
</div>
</nav>
<div class="docs-main">
<header class="docs-navbar">
<a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#">
</a>
<nav class="breadcrumb">
<ul class="is-hidden-mobile">
<li class="is-active">
<a href="formats.html">Formats
</a>
</li>
</ul>
<ul class="is-hidden-tablet">
<li class="is-active">
<a href="formats.html">Formats
</a>
</li>
</ul>
</nav>
<div class="docs-right">
<a class="docs-navbar-link" href="https://github.com/tanaylab/DataAxesFormats.jl/blob/main{path}?plain=1#L{line}" title="View the repository on GitHub">
<span class="docs-icon fa-brands">
</span>
<span class="docs-label is-hidden-touch">GitHub
</span>
</a>
<a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings">
</a>
<a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings">
</a>
</div>
</header>
<article class="content" id="documenter-page">
<h1 id="Formats">
<a class="docs-heading-anchor" href="#Formats">Formats
</a>
<a id="Formats-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Formats" title="Permalink">
</a>
</h1>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats">
<a class="docstring-binding" href="#DataAxesFormats.Formats">
<code>DataAxesFormats.Formats
</code>
</a> — 
<span class="docstring-category">Module
</span>
</summary>
<section>
<div>
<p>The 
<a href="formats.html#DataAxesFormats.Formats.FormatReader">
<code>FormatReader
</code>
</a> and 
<a href="formats.html#DataAxesFormats.Formats.FormatWriter">
<code>FormatWriter
</code>
</a> interfaces specify a low-level API for storing 
<code>Daf
</code> data. To extend 
<code>Daf
</code> to support an additional format, create a new implementation of this API.
</p>
<p>A storage format object contains some named scalar data, a set of axes (each with a unique name for each entry), and named vector and matrix data based on these axes.
</p>
<p>Data properties are identified by a unique name given the axes they are based on. That is, there is a separate namespace for scalar properties, vector properties for each specific axis, and matrix properties for each (ordered) pair of axes.
</p>
<p>For matrices, we keep careful track of their layout(@ref). Specifically, a storage format only deals with column-major matrices, listed under the rows axis first and the columns axis second. A storage format object may hold two copies of the same matrix, in both possible memory layouts, in which case it will be listed twice, under both axes orders.
</p>
<p>In general, storage format objects are as &quot;dumb&quot; as possible, to make it easier to support new storage formats. The required functions implement a glorified key-value repository, with the absolutely minimal necessary logic to deal with the separate property namespaces listed above.
</p>
<p>For clarity of documentation, we split the type hierarchy to 
<a href="formats.html#DataAxesFormats.Formats.DafWriter">
<code>DafWriter
</code>
</a> 
<code>&lt;:
</code> 
<a href="formats.html#DataAxesFormats.Formats.FormatWriter">
<code>FormatWriter
</code>
</a> 
<code>&lt;:
</code> 
<a href="formats.html#DataAxesFormats.Formats.DafReader">
<code>DafReader
</code>
</a> 
<code>&lt;:
</code> 
<a href="formats.html#DataAxesFormats.Formats.FormatReader">
<code>FormatReader
</code>
</a>.
</p>
<p>The functions listed here use the 
<a href="formats.html#DataAxesFormats.Formats.FormatReader">
<code>FormatReader
</code>
</a> for read-only operations and 
<a href="formats.html#DataAxesFormats.Formats.FormatWriter">
<code>FormatWriter
</code>
</a> for write operations into a 
<code>Daf
</code> storage. This is a low-level API, not meant to be used from outside the package, and therefore is not re-exported from the top-level 
<code>DataAxesFormats
</code> namespace.
</p>
<p>In contrast, the functions using 
<a href="formats.html#DataAxesFormats.Formats.DafReader">
<code>DafReader
</code>
</a> and 
<a href="formats.html#DataAxesFormats.Formats.DafWriter">
<code>DafWriter
</code>
</a> describe the high-level API meant to be used from outside the package, and are re-exported. These functions are listed in the 
<code>DataAxesFormats.Readers
</code> and 
<code>DataAxesFormats.Writers
</code> modules. They provide all the logic common to any storage format, allowing us to keep the format-specific functions as simple as possible.
</p>
<p>That is, when implementing a new 
<code>Daf
</code> storage format, you should write 
<code>struct MyFormat &lt;: DafWriter
</code>, and implement the functions listed here for both 
<a href="formats.html#DataAxesFormats.Formats.FormatReader">
<code>FormatReader
</code>
</a> and 
<a href="formats.html#DataAxesFormats.Formats.FormatWriter">
<code>FormatWriter
</code>
</a>.
</p>
</div>
</section>
</details>
</article>
<h2 id="Read-API">
<a class="docs-heading-anchor" href="#Read-API">Read API
</a>
<a id="Read-API-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Read-API" title="Permalink">
</a>
</h2>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.DafReader">
<a class="docstring-binding" href="#DataAxesFormats.Formats.DafReader">
<code>DataAxesFormats.Formats.DafReader
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<p>A high-level abstract interface for read-only access to 
<code>Daf
</code> data.
</p>
<p>All the functions for this type are provided based on the functions required for 
<a href="formats.html#DataAxesFormats.Formats.FormatReader">
<code>FormatReader
</code>
</a>. See the 
<a href="readers.html#DataAxesFormats.Readers">
<code>Readers
</code>
</a> module for their description.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.FormatReader">
<a class="docstring-binding" href="#DataAxesFormats.Formats.FormatReader">
<code>DataAxesFormats.Formats.FormatReader
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<p>An low-level abstract interface for reading from 
<code>Daf
</code> storage formats.
</p>
<p>We require each storage format to have a 
<code>.name
</code> and an 
<code>.internal::
</code>
<a href="formats.html#DataAxesFormats.Formats.Internal">
<code>Internal
</code>
</a> property. This enables all the high-level 
<a href="formats.html#DataAxesFormats.Formats.DafReader">
<code>DafReader
</code>
</a> functions.
</p>
<p>Each storage format must implement the functions listed below for reading from the storage.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.Internal">
<a class="docstring-binding" href="#DataAxesFormats.Formats.Internal">
<code>DataAxesFormats.Formats.Internal
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">struct Internal ... end
</code>
</pre>
<p>Internal data we need to keep in any concrete 
<a href="formats.html#DataAxesFormats.Formats.FormatReader">
<code>FormatReader
</code>
</a>. This has to be available as a 
<code>.internal
</code> data member of the concrete format. This enables all the high-level 
<a href="formats.html#DataAxesFormats.Formats.DafReader">
<code>DafReader
</code>
</a> and 
<a href="formats.html#DataAxesFormats.Formats.DafWriter">
<code>DafWriter
</code>
</a> functions.
</p>
<p>The constructor will automatically call 
<code>unique_name
</code> to try and make the names unique for improved error messages.
</p>
</div>
</section>
</details>
</article>
<h3 id="Caching">
<a class="docs-heading-anchor" href="#Caching">Caching
</a>
<a id="Caching-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Caching" title="Permalink">
</a>
</h3>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.CacheGroup">
<a class="docstring-binding" href="#DataAxesFormats.Formats.CacheGroup">
<code>DataAxesFormats.Formats.CacheGroup
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<p>Types of cached data inside 
<code>Daf
</code>.
</p>
<ul>
<li>
<code>MappedData
</code> - memory-mapped disk data. This is the cheapest data, as it doesn&#39;t put pressure on the garbage collector. It requires some OS resources to maintain the mapping, and physical memory for the subset of the data that is actually being accessed. That is, one can memory map larger data than the physical memory, and performance will be good, as long as the subset of the data that is actually accessed is small enough to fit in memory. If it isn&#39;t, the performance will drop (a lot!) because the OS will be continuously reading data pages from disk - but it will not crash due to an out of memory error. It is very important not to re-map the same data twice because that causes all sort of inefficiencies and edge cases in the hardware and low-level software.
</li>
<li>
<code>MemoryData
</code> - a copy of data (from disk, or computed). This does pressure the garbage collector and can cause out of memory errors. However, recomputing or re-fetching the data from disk is slow, so caching this data is crucial for performance.
</li>
<li>
<code>QueryData
</code> - data that is computed by queries based on stored data (e.g., masked data, or results of a reduction or an element-wise operation). This again takes up application memory and may cause out of memory errors, but it is very useful to cache the results when the same query is executed multiple times (e.g., when using views). Manually executing queries therefore allows to explicitly disable the caching of the query results, since some queries will not be repeated.
</li>
</ul>
<p>If too much data has been cached, call 
<a href="formats.html#DataAxesFormats.Formats.empty_cache!">
<code>empty_cache!
</code>
</a> to release it.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.empty_cache!">
<a class="docstring-binding" href="#DataAxesFormats.Formats.empty_cache!">
<code>DataAxesFormats.Formats.empty_cache!
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">empty_cache!(
    daf::DafReader;
    [clear::Maybe{CacheGroup} = nothing,
    keep::Maybe{CacheGroup} = nothing]
)::Nothing
</code>
</pre>
<p>Clear some cached data. By default, completely empties the caches. You can specify either 
<code>clear
</code>, to only forget a specific 
<a href="formats.html#DataAxesFormats.Formats.CacheGroup">
<code>CacheGroup
</code>
</a> (e.g., for clearing only 
<code>QueryData
</code>), or 
<code>keep
</code>, to forget everything except a specific 
<a href="formats.html#DataAxesFormats.Formats.CacheGroup">
<code>CacheGroup
</code>
</a> (e.g., for keeping only 
<code>MappedData
</code>). You can&#39;t specify both 
<code>clear
</code> and 
<code>keep
</code>.
</p>
<div class="admonition is-info" id="Note-69a0c03308ee4e4c">
<header class="admonition-header">Note
<a class="admonition-anchor" href="#Note-69a0c03308ee4e4c" title="Permalink">
</a>
</header>
<div class="admonition-body">
<p>If there are any slow cache update operations in flight (matrix relayout, queries) then this will wait until they are done to ensure that the cache is in a consistent state.
</p>
</div>
</div>
</div>
</section>
</details>
</article>
<h3 id="Description">
<a class="docs-heading-anchor" href="#Description">Description
</a>
<a id="Description-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Description" title="Permalink">
</a>
</h3>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_description_header">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_description_header">
<code>DataAxesFormats.Formats.format_description_header
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_description_header(format::FormatReader, lines::Vector{String}, deep::Bool)::Nothing
</code>
</pre>
<p>Allow a 
<code>format
</code> to amit additional description header lines.
</p>
<p>This trusts that we have a read lock on the data set.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_description_footer">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_description_footer">
<code>DataAxesFormats.Formats.format_description_footer
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_description_footer(format::FormatReader, lines::Vector{String}; cache::Bool, deep::Bool, tensors::Bool)::Nothing
</code>
</pre>
<p>Allow a 
<code>format
</code> to amit additional description footer lines. If 
<code>deep
</code>, this also emit the description of any data sets nested in this one, if any.
</p>
<p>This trusts that we have a read lock on the data set.
</p>
</div>
</section>
</details>
</article>
<h3 id="Scalar-properties">
<a class="docs-heading-anchor" href="#Scalar-properties">Scalar properties
</a>
<a id="Scalar-properties-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Scalar-properties" title="Permalink">
</a>
</h3>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_has_scalar">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_has_scalar">
<code>DataAxesFormats.Formats.format_has_scalar
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_has_scalar(format::FormatReader, name::AbstractString)::Bool
</code>
</pre>
<p>Check whether a scalar property with some 
<code>name
</code> exists in 
<code>format
</code>.
</p>
<p>This trusts that we have a read lock on the data set.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_scalars_set">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_scalars_set">
<code>DataAxesFormats.Formats.format_scalars_set
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_scalars_set(format::FormatReader)::AbstractSet{&lt;:AbstractString}
</code>
</pre>
<p>The names of the scalar properties in 
<code>format
</code>.
</p>
<p>This trusts that we have a read lock on the data set.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_get_scalar">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_get_scalar">
<code>DataAxesFormats.Formats.format_get_scalar
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_get_scalar(format::FormatReader, name::AbstractString)::StorageScalar
</code>
</pre>
<p>Implement fetching the value of a scalar property with some 
<code>name
</code> in 
<code>format
</code>.
</p>
<p>This trusts that we have a read lock on the data set, and that the 
<code>name
</code> scalar property exists in 
<code>format
</code>.
</p>
</div>
</section>
</details>
</article>
<h3 id="Data-axes">
<a class="docs-heading-anchor" href="#Data-axes">Data axes
</a>
<a id="Data-axes-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Data-axes" title="Permalink">
</a>
</h3>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_has_axis">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_has_axis">
<code>DataAxesFormats.Formats.format_has_axis
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_has_axis(format::FormatReader, axis::AbstractString; for_change::Bool)::Bool
</code>
</pre>
<p>Check whether some 
<code>axis
</code> exists in 
<code>format
</code>. If 
<code>for_change
</code>, this is done just prior to adding or deleting the axis.
</p>
<p>This trusts that we have a read lock on the data set.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_axes_set">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_axes_set">
<code>DataAxesFormats.Formats.format_axes_set
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_axes_set(format::FormatReader)::AbstractSet{&lt;:AbstractString}
</code>
</pre>
<p>The names of the axes of 
<code>format
</code>.
</p>
<p>This trusts that we have a read lock on the data set.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_axis_vector">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_axis_vector">
<code>DataAxesFormats.Formats.format_axis_vector
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_axis_vector(format::FormatReader, axis::AbstractString)::AbstractVector{&lt;:AbstractString}
</code>
</pre>
<p>Implement fetching the unique names of the entries of some 
<code>axis
</code> of 
<code>format
</code>.
</p>
<p>This trusts that we have a read lock on the data set, and that the 
<code>axis
</code> exists in 
<code>format
</code>.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_axis_length">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_axis_length">
<code>DataAxesFormats.Formats.format_axis_length
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_axis_length(format::FormatReader, axis::AbstractString)::Int64
</code>
</pre>
<p>Implement fetching the number of entries along the 
<code>axis
</code>.
</p>
<p>This trusts that we have a read lock on the data set, and that the 
<code>axis
</code> exists in 
<code>format
</code>.
</p>
</div>
</section>
</details>
</article>
<h3 id="Vector-properties">
<a class="docs-heading-anchor" href="#Vector-properties">Vector properties
</a>
<a id="Vector-properties-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Vector-properties" title="Permalink">
</a>
</h3>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_has_vector">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_has_vector">
<code>DataAxesFormats.Formats.format_has_vector
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_has_vector(format::FormatReader, axis::AbstractString, name::AbstractString)::Bool
</code>
</pre>
<p>Implement checking whether a vector property with some 
<code>name
</code> exists for the 
<code>axis
</code> in 
<code>format
</code>.
</p>
<p>This trusts that we have a read lock on the data set, that the 
<code>axis
</code> exists in 
<code>format
</code> and that the property name isn&#39;t 
<code>name
</code>.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_vectors_set">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_vectors_set">
<code>DataAxesFormats.Formats.format_vectors_set
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_vectors_set(format::FormatReader, axis::AbstractString)::AbstractSet{&lt;:AbstractString}
</code>
</pre>
<p>Implement fetching the names of the vectors for the 
<code>axis
</code> in 
<code>format
</code>, 
<strong>not
</strong> including the special 
<code>name
</code> property.
</p>
<p>This trusts that we have a read lock on the data set, and that the 
<code>axis
</code> exists in 
<code>format
</code>.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_get_vector">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_get_vector">
<code>DataAxesFormats.Formats.format_get_vector
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_get_vector(format::FormatReader, axis::AbstractString, name::AbstractString)::StorageVector
</code>
</pre>
<p>Implement fetching the vector property with some 
<code>name
</code> for some 
<code>axis
</code> in 
<code>format
</code>.
</p>
<p>This trusts that we have a read lock on the data set, that the 
<code>axis
</code> exists in 
<code>format
</code>, and the 
<code>name
</code> vector property exists for the 
<code>axis
</code>.
</p>
</div>
</section>
</details>
</article>
<h3 id="Matrix-properties">
<a class="docs-heading-anchor" href="#Matrix-properties">Matrix properties
</a>
<a id="Matrix-properties-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Matrix-properties" title="Permalink">
</a>
</h3>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_has_matrix">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_has_matrix">
<code>DataAxesFormats.Formats.format_has_matrix
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_has_matrix(
    format::FormatReader,
    rows_axis::AbstractString,
    columns_axis::AbstractString,
    name::AbstractString;
)::Bool
</code>
</pre>
<p>Implement checking whether a matrix property with some 
<code>name
</code> exists for the 
<code>rows_axis
</code> and the 
<code>columns_axis
</code> in 
<code>format
</code>. If 
<code>cache
</code> also checks whether the matrix exists in the cache.
</p>
<p>This trusts that we have a read lock on the data set, and that the 
<code>rows_axis
</code> and the 
<code>columns_axis
</code> exist in 
<code>format
</code>.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_matrices_set">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_matrices_set">
<code>DataAxesFormats.Formats.format_matrices_set
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_matrices_set(
    format::FormatReader,
    rows_axis::AbstractString,
    columns_axis::AbstractString,
)::AbstractSet{&lt;:AbstractString}
</code>
</pre>
<p>Implement fetching the names of the matrix properties for the 
<code>rows_axis
</code> and 
<code>columns_axis
</code> in 
<code>format
</code>.
</p>
<p>This trusts that we have a read lock on the data set, and that the 
<code>rows_axis
</code> and 
<code>columns_axis
</code> exist in 
<code>format
</code>.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_get_matrix">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_get_matrix">
<code>DataAxesFormats.Formats.format_get_matrix
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_get_matrix(
    format::FormatReader,
    rows_axis::AbstractString,
    columns_axis::AbstractString,
    name::AbstractString
)::StorageMatrix
</code>
</pre>
<p>Implement fetching the matrix property with some 
<code>name
</code> for some 
<code>rows_axis
</code> and 
<code>columns_axis
</code> in 
<code>format
</code>.
</p>
<p>This trusts that we have a read lock on the data set, and that the 
<code>rows_axis
</code> and 
<code>columns_axis
</code> exist in 
<code>format
</code>, and the 
<code>name
</code> matrix property exists for them.
</p>
</div>
</section>
</details>
</article>
<h2 id="Write-API">
<a class="docs-heading-anchor" href="#Write-API">Write API
</a>
<a id="Write-API-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Write-API" title="Permalink">
</a>
</h2>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.DafWriter">
<a class="docstring-binding" href="#DataAxesFormats.Formats.DafWriter">
<code>DataAxesFormats.Formats.DafWriter
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<p>A high-level abstract interface for write access to 
<code>Daf
</code> data.
</p>
<p>All the functions for this type are provided based on the functions required for 
<a href="formats.html#DataAxesFormats.Formats.FormatWriter">
<code>FormatWriter
</code>
</a>. See the 
<a href="writers.html#DataAxesFormats.Writers">
<code>Writers
</code>
</a> module for their description.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.FormatWriter">
<a class="docstring-binding" href="#DataAxesFormats.Formats.FormatWriter">
<code>DataAxesFormats.Formats.FormatWriter
</code>
</a> — 
<span class="docstring-category">Type
</span>
</summary>
<section>
<div>
<p>An abstract interface for writing into 
<code>Daf
</code> storage formats.
</p>
<p>Each storage format must implement the functions listed below for writing into the storage.
</p>
</div>
</section>
</details>
</article>
<h3 id="Scalar-properties-2">
<a class="docs-heading-anchor" href="#Scalar-properties-2">Scalar properties
</a>
<a class="docs-heading-anchor-permalink" href="#Scalar-properties-2" title="Permalink">
</a>
</h3>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_set_scalar!">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_set_scalar!">
<code>DataAxesFormats.Formats.format_set_scalar!
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_set_scalar!(
    format::FormatWriter,
    name::AbstractString,
    value::StorageScalar,
)::Nothing
</code>
</pre>
<p>Implement setting the 
<code>value
</code> of a scalar property with some 
<code>name
</code> in 
<code>format
</code>.
</p>
<p>This trusts that we have a write lock on the data set, and that the 
<code>name
</code> scalar property does not exist in 
<code>format
</code>.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_delete_scalar!">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_delete_scalar!">
<code>DataAxesFormats.Formats.format_delete_scalar!
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_delete_scalar!(
    format::FormatWriter,
    name::AbstractString;
    for_set::Bool
)::Nothing
</code>
</pre>
<p>Implement deleting a scalar property with some 
<code>name
</code> from 
<code>format
</code>. If 
<code>for_set
</code>, this is done just prior to setting the scalar with a different value.
</p>
<p>This trusts that we have a write lock on the data set, and that the 
<code>name
</code> scalar property exists in 
<code>format
</code>.
</p>
</div>
</section>
</details>
</article>
<h3 id="Data-axes-2">
<a class="docs-heading-anchor" href="#Data-axes-2">Data axes
</a>
<a class="docs-heading-anchor-permalink" href="#Data-axes-2" title="Permalink">
</a>
</h3>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_add_axis!">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_add_axis!">
<code>DataAxesFormats.Formats.format_add_axis!
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_add_axis!(
    format::FormatWriter,
    axis::AbstractString,
    entries::AbstractVector{&lt;:AbstractString}
)::Nothing
</code>
</pre>
<p>Implement adding a new 
<code>axis
</code> to 
<code>format
</code>.
</p>
<p>This trusts we have a write lock on the data set, that the 
<code>axis
</code> does not already exist in 
<code>format
</code>, and that the names of the 
<code>entries
</code> are unique.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_delete_axis!">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_delete_axis!">
<code>DataAxesFormats.Formats.format_delete_axis!
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_delete_axis!(format::FormatWriter, axis::AbstractString)::Nothing
</code>
</pre>
<p>Implement deleting some 
<code>axis
</code> from 
<code>format
</code>.
</p>
<p>This trusts This trusts we have a write lock on the data set, that the 
<code>axis
</code> exists in 
<code>format
</code>, and that all properties that are based on this axis have already been deleted.
</p>
</div>
</section>
</details>
</article>
<h3 id="Vector-properties-2">
<a class="docs-heading-anchor" href="#Vector-properties-2">Vector properties
</a>
<a class="docs-heading-anchor-permalink" href="#Vector-properties-2" title="Permalink">
</a>
</h3>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_set_vector!">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_set_vector!">
<code>DataAxesFormats.Formats.format_set_vector!
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_set_vector!(
    format::FormatWriter,
    axis::AbstractString,
    name::AbstractString,
    vector::Union{StorageScalar, StorageVector},
)::Nothing
</code>
</pre>
<p>Implement setting a vector property with some 
<code>name
</code> for some 
<code>axis
</code> in 
<code>format
</code>.
</p>
<p>If the 
<code>vector
</code> specified is actually a 
<a href="storage_types.html#DataAxesFormats.StorageTypes.StorageScalar">
<code>StorageScalar
</code>
</a>, the stored vector is filled with this value.
</p>
<p>This trusts we have a write lock on the data set, that the 
<code>axis
</code> exists in 
<code>format
</code>, that the vector property 
<code>name
</code> isn&#39;t 
<code>&quot;name&quot;
</code>, that it does not exist for the 
<code>axis
</code>, and that the 
<code>vector
</code> has the appropriate length for it.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_delete_vector!">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_delete_vector!">
<code>DataAxesFormats.Formats.format_delete_vector!
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_delete_vector!(
    format::FormatWriter,
    axis::AbstractString,
    name::AbstractString;
    for_set::Bool
)::Nothing
</code>
</pre>
<p>Implement deleting a vector property with some 
<code>name
</code> for some 
<code>axis
</code> from 
<code>format
</code>. If 
<code>for_set
</code>, this is done just prior to setting the vector with a different value.
</p>
<p>This trusts we have a write lock on the data set, that the 
<code>axis
</code> exists in 
<code>format
</code>, that the vector property name isn&#39;t 
<code>name
</code>, and that the 
<code>name
</code> vector exists for the 
<code>axis
</code>.
</p>
</div>
</section>
</details>
</article>
<h3 id="Matrix-properties-2">
<a class="docs-heading-anchor" href="#Matrix-properties-2">Matrix properties
</a>
<a class="docs-heading-anchor-permalink" href="#Matrix-properties-2" title="Permalink">
</a>
</h3>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_set_matrix!">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_set_matrix!">
<code>DataAxesFormats.Formats.format_set_matrix!
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_set_matrix!(
    format::FormatWriter,
    rows_axis::AbstractString,
    columns_axis::AbstractString,
    name::AbstractString,
    matrix::StorageMatrix,
)::Nothing
</code>
</pre>
<p>Implement setting the matrix property with some 
<code>name
</code> for some 
<code>rows_axis
</code> and 
<code>columns_axis
</code> in 
<code>format
</code>.
</p>
<p>If the 
<code>matrix
</code> specified is actually a 
<a href="storage_types.html#DataAxesFormats.StorageTypes.StorageScalar">
<code>StorageScalar
</code>
</a>, the stored matrix is filled with this value.
</p>
<p>This trusts we have a write lock on the data set, that the 
<code>rows_axis
</code> and 
<code>columns_axis
</code> exist in 
<code>format
</code>, that the 
<code>name
</code> matrix property does not exist for them, and that the 
<code>matrix
</code> is column-major of the appropriate size for it.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_relayout_matrix!">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_relayout_matrix!">
<code>DataAxesFormats.Formats.format_relayout_matrix!
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_relayout_matrix!(
    format::FormatWriter,
    rows_axis::AbstractString,
    columns_axis::AbstractString,
    name::AbstractString,
    matrix::StorageMatrix,
)::StorageMatrix
</code>
</pre>
<p>
<code>relayout!
</code> the existing 
<code>name
</code> column-major 
<code>matrix
</code> property for the 
<code>rows_axis
</code> and the 
<code>columns_axis
</code> and store the results as a row-major matrix property (that is, with flipped axes).
</p>
<p>This trusts we have a write lock on the data set, that the 
<code>rows_axis
</code> and 
<code>columns_axis
</code> are different from each other, exist in 
<code>format
</code>, that the 
<code>name
</code> matrix property exists for them, and that it does not exist for the flipped axes.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_delete_matrix!">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_delete_matrix!">
<code>DataAxesFormats.Formats.format_delete_matrix!
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_delete_matrix!(
    format::FormatWriter,
    rows_axis::AbstractString,
    columns_axis::AbstractString,
    name::AbstractString;
    for_set::Bool
)::StorageMatrix
</code>
</pre>
<p>Implement deleting a matrix property with some 
<code>name
</code> for some 
<code>rows_axis
</code> and 
<code>columns_axis
</code> from 
<code>format
</code>. If 
<code>for_set
</code>, this is done just prior to setting the matrix with a different value.
</p>
<p>This trusts we have a write lock on the data set, that the 
<code>rows_axis
</code> and 
<code>columns_axis
</code> exist in 
<code>format
</code>, and that the 
<code>name
</code> matrix property exists for them.
</p>
</div>
</section>
</details>
</article>
<h3 id="Creating-properties">
<a class="docs-heading-anchor" href="#Creating-properties">Creating properties
</a>
<a id="Creating-properties-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Creating-properties" title="Permalink">
</a>
</h3>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_get_empty_dense_vector!">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_get_empty_dense_vector!">
<code>DataAxesFormats.Formats.format_get_empty_dense_vector!
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_get_empty_dense_vector!(
    format::FormatWriter,
    axis::AbstractString,
    name::AbstractString,
    eltype::Type{T},
)::Vector{T} where {T &lt;: StorageReal}
</code>
</pre>
<p>Implement setting a vector property with some 
<code>name
</code> for some 
<code>axis
</code> in 
<code>format
</code>.
</p>
<p>Implement creating an empty dense 
<code>matrix
</code> with some 
<code>name
</code> for some 
<code>rows_axis
</code> and 
<code>columns_axis
</code> in 
<code>format
</code>.
</p>
<p>This trusts we have a write lock on the data set, that the 
<code>axis
</code> exists in 
<code>format
</code> and that the vector property 
<code>name
</code> isn&#39;t 
<code>&quot;name&quot;
</code>, and that it does not exist for the 
<code>axis
</code>.
</p>
<div class="admonition is-info" id="Note-f4e557ade4b46153">
<header class="admonition-header">Note
<a class="admonition-anchor" href="#Note-f4e557ade4b46153" title="Permalink">
</a>
</header>
<div class="admonition-body">
<p>The return type of this function is always a 
<strong>functionally
</strong> dense vector, that is, it will have 
<code>strides
</code> of 
<code>(1,)
</code>, so that elements are consecutive in memory. However it need not be an actual 
<code>DenseVector
</code> because of Julia&#39;s type system&#39;s limitations.
</p>
</div>
</div>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_get_empty_sparse_vector!">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_get_empty_sparse_vector!">
<code>DataAxesFormats.Formats.format_get_empty_sparse_vector!
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_get_empty_sparse_vector!(
    format::FormatWriter,
    axis::AbstractString,
    name::AbstractString,
    eltype::Type{T},
    nnz::StorageInteger,
    indtype::Type{I},
)::Tuple{AbstractVector{I}, AbstractVector{T}, Any}
where {T &lt;: StorageReal, I &lt;: StorageInteger}
</code>
</pre>
<p>Implement creating an empty dense vector property with some 
<code>name
</code> for some 
<code>rows_axis
</code> and 
<code>columns_axis
</code> in 
<code>format
</code>.
</p>
<p>This trusts we have a write lock on the data set, that the 
<code>axis
</code> exists in 
<code>format
</code> and that the vector property 
<code>name
</code> isn&#39;t 
<code>&quot;name&quot;
</code>, and that it does not exist for the 
<code>axis
</code>.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_filled_empty_sparse_vector!">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_filled_empty_sparse_vector!">
<code>DataAxesFormats.Formats.format_filled_empty_sparse_vector!
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_filled_empty_sparse_vector!(
    format::FormatWriter,
    axis::AbstractString,
    name::AbstractString,
    filled::SparseVector{&lt;:StorageReal, &lt;:StorageInteger},
)::Nothing
</code>
</pre>
<p>Allow the 
<code>format
</code> to perform caching once the empty sparse vector has been 
<code>filled
</code>. By default this does nothing.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_get_empty_dense_matrix!">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_get_empty_dense_matrix!">
<code>DataAxesFormats.Formats.format_get_empty_dense_matrix!
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_get_empty_dense_matrix!(
    format::FormatWriter,
    rows_axis::AbstractString,
    columns_axis::AbstractString,
    name::AbstractString,
    eltype::Type{T},
)::AbstractMatrix{T} where {T &lt;: StorageReal}
</code>
</pre>
<p>Implement creating an empty dense matrix property with some 
<code>name
</code> for some 
<code>rows_axis
</code> and 
<code>columns_axis
</code> in 
<code>format
</code>.
</p>
<p>This trusts we have a write lock on the data set, that the 
<code>rows_axis
</code> and 
<code>columns_axis
</code> exist in 
<code>format
</code> and that the 
<code>name
</code> matrix property does not exist for them.
</p>
<div class="admonition is-info" id="Note-751dfab0043b0024">
<header class="admonition-header">Note
<a class="admonition-anchor" href="#Note-751dfab0043b0024" title="Permalink">
</a>
</header>
<div class="admonition-body">
<p>The return type of this function is always a 
<strong>functionally
</strong> dense vector, that is, it will have 
<code>strides
</code> of 
<code>(1,nrows)
</code>, so that elements are consecutive in memory. However it need not be an actual 
<code>DenseMatrix
</code> because of Julia&#39;s type system&#39;s limitations.
</p>
</div>
</div>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_get_empty_sparse_matrix!">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_get_empty_sparse_matrix!">
<code>DataAxesFormats.Formats.format_get_empty_sparse_matrix!
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_get_empty_sparse_matrix!(
    format::FormatWriter,
    rows_axis::AbstractString,
    columns_axis::AbstractString,
    name::AbstractString,
    eltype::Type{T},
    intdype::Type{I},
    nnz::StorageInteger,
)::Tuple{AbstractVector{I}, AbstractVector{I}, AbstractVector{T}, Any}
where {T &lt;: StorageReal, I &lt;: StorageInteger}
</code>
</pre>
<p>Implement creating an empty sparse matrix property with some 
<code>name
</code> for some 
<code>rows_axis
</code> and 
<code>columns_axis
</code> in 
<code>format
</code>.
</p>
<p>This trusts we have a write lock on the data set, that the 
<code>rows_axis
</code> and 
<code>columns_axis
</code> exist in 
<code>format
</code> and that the 
<code>name
</code> matrix property does not exist for them.
</p>
</div>
</section>
</details>
</article>
<article>
<details class="docstring" open="true">
<summary id="DataAxesFormats.Formats.format_filled_empty_sparse_matrix!">
<a class="docstring-binding" href="#DataAxesFormats.Formats.format_filled_empty_sparse_matrix!">
<code>DataAxesFormats.Formats.format_filled_empty_sparse_matrix!
</code>
</a> — 
<span class="docstring-category">Function
</span>
</summary>
<section>
<div>
<pre>
<code class="language-julia hljs">format_filled_empty_sparse_matrix!(
    format::FormatWriter,
    rows_axis::AbstractString,
    columns_axis::AbstractString,
    name::AbstractString,
    filled::SparseMatrixCSC{&lt;:StorageReal, &lt;:StorageInteger},
)::Nothing
</code>
</pre>
<p>Allow the 
<code>format
</code> to perform caching once the empty sparse matrix has been 
<code>filled
</code>. By default this does nothing.
</p>
</div>
</section>
</details>
</article>
<h2 id="Index">
<a class="docs-heading-anchor" href="#Index">Index
</a>
<a id="Index-1">
</a>
<a class="docs-heading-anchor-permalink" href="#Index" title="Permalink">
</a>
</h2>
<ul>
<li>
<a href="formats.html#DataAxesFormats.Formats">
<code>DataAxesFormats.Formats
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.CacheGroup">
<code>DataAxesFormats.Formats.CacheGroup
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.DafReader">
<code>DataAxesFormats.Formats.DafReader
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.DafWriter">
<code>DataAxesFormats.Formats.DafWriter
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.FormatReader">
<code>DataAxesFormats.Formats.FormatReader
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.FormatWriter">
<code>DataAxesFormats.Formats.FormatWriter
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.Internal">
<code>DataAxesFormats.Formats.Internal
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.empty_cache!">
<code>DataAxesFormats.Formats.empty_cache!
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_add_axis!">
<code>DataAxesFormats.Formats.format_add_axis!
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_axes_set">
<code>DataAxesFormats.Formats.format_axes_set
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_axis_length">
<code>DataAxesFormats.Formats.format_axis_length
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_axis_vector">
<code>DataAxesFormats.Formats.format_axis_vector
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_delete_axis!">
<code>DataAxesFormats.Formats.format_delete_axis!
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_delete_matrix!">
<code>DataAxesFormats.Formats.format_delete_matrix!
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_delete_scalar!">
<code>DataAxesFormats.Formats.format_delete_scalar!
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_delete_vector!">
<code>DataAxesFormats.Formats.format_delete_vector!
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_description_footer">
<code>DataAxesFormats.Formats.format_description_footer
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_description_header">
<code>DataAxesFormats.Formats.format_description_header
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_filled_empty_sparse_matrix!">
<code>DataAxesFormats.Formats.format_filled_empty_sparse_matrix!
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_filled_empty_sparse_vector!">
<code>DataAxesFormats.Formats.format_filled_empty_sparse_vector!
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_get_empty_dense_matrix!">
<code>DataAxesFormats.Formats.format_get_empty_dense_matrix!
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_get_empty_dense_vector!">
<code>DataAxesFormats.Formats.format_get_empty_dense_vector!
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_get_empty_sparse_matrix!">
<code>DataAxesFormats.Formats.format_get_empty_sparse_matrix!
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_get_empty_sparse_vector!">
<code>DataAxesFormats.Formats.format_get_empty_sparse_vector!
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_get_matrix">
<code>DataAxesFormats.Formats.format_get_matrix
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_get_scalar">
<code>DataAxesFormats.Formats.format_get_scalar
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_get_vector">
<code>DataAxesFormats.Formats.format_get_vector
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_has_axis">
<code>DataAxesFormats.Formats.format_has_axis
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_has_matrix">
<code>DataAxesFormats.Formats.format_has_matrix
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_has_scalar">
<code>DataAxesFormats.Formats.format_has_scalar
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_has_vector">
<code>DataAxesFormats.Formats.format_has_vector
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_matrices_set">
<code>DataAxesFormats.Formats.format_matrices_set
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_relayout_matrix!">
<code>DataAxesFormats.Formats.format_relayout_matrix!
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_scalars_set">
<code>DataAxesFormats.Formats.format_scalars_set
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_set_matrix!">
<code>DataAxesFormats.Formats.format_set_matrix!
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_set_scalar!">
<code>DataAxesFormats.Formats.format_set_scalar!
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_set_vector!">
<code>DataAxesFormats.Formats.format_set_vector!
</code>
</a>
</li>
<li>
<a href="formats.html#DataAxesFormats.Formats.format_vectors_set">
<code>DataAxesFormats.Formats.format_vectors_set
</code>
</a>
</li>
</ul>
</article>
<nav class="docs-footer">
<a class="docs-footer-prevpage" href="contracts.html">« Contracts
</a>
<a class="docs-footer-nextpage" href="keys.html">Keys »
</a>
<div class="flexbox-break">
</div>
<p class="footer-message">Powered by 
<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl
</a> and the 
<a href="https://julialang.org/">Julia Programming Language
</a>.
</p>
</nav>
</div>
<div class="modal" id="documenter-settings">
<div class="modal-background">
</div>
<div class="modal-card">
<header class="modal-card-head">
<p class="modal-card-title">Settings
</p>
<button class="delete">
</button>
</header>
<section class="modal-card-body">
<p>
<label class="label">Theme
</label>
<div class="select">
<select id="documenter-themepicker">
<option value="auto">Automatic (OS)
</option>
<option value="documenter-light">documenter-light
</option>
<option value="documenter-dark">documenter-dark
</option>
<option value="catppuccin-latte">catppuccin-latte
</option>
<option value="catppuccin-frappe">catppuccin-frappe
</option>
<option value="catppuccin-macchiato">catppuccin-macchiato
</option>
<option value="catppuccin-mocha">catppuccin-mocha
</option>
</select>
</div>
</p>
<hr/>
<p>This document was generated with 
<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl
</a> version 1.16.1. Using Julia version 1.11.8.
</p>
</section>
<footer class="modal-card-foot">
</footer>
</div>
</div>
</div>
</body>
</html>
